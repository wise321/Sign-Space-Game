<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Sign — Retro Descent</title>
<style>
  :root{
    --bg:#0a0f1a;
    --wall1:#ffb23c;
    --wall2:#cc7a17;
    --ui:#98e7ff;
    --text:#eaf4ff;
    --accent:#ff9a2a;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;overflow:hidden;touch-action:none;
    -webkit-user-select:none;user-select:none}
  canvas{display:block;width:100vw;height:100vh;background:linear-gradient(180deg,#0b1324,#070e1c);}
  /* Top UI (outside wall; tiny gap during gameplay) */
  #topUI{position:fixed;top:4px;left:50%;transform:translateX(-50%);
    display:flex;gap:8px;align-items:center;z-index:4;pointer-events:none}
  .bar{width:clamp(160px,70vw,240px);height:12px;border-radius:9px;padding:2px;background:rgba(255,255,255,.06);
    box-shadow:0 0 0 1px rgba(255,255,255,.08) inset, 0 4px 20px rgba(0,0,0,.5);}
  .bar>span{display:block;height:100%;width:0%;border-radius:7px;background:linear-gradient(90deg,#1bd0ff,#7bffcf);
    box-shadow:0 0 12px rgba(60,220,255,.5);transition:width .1s ease-out;}
  .pill{min-width:58px;text-align:center;font-weight:800;font-size:11px;padding:4px 10px;border-radius:999px;
    background:rgba(255,255,255,.08);box-shadow:0 0 0 1px rgba(255,255,255,.12) inset}

  /* Game Over overlay (bigger for touch) */
  #gameOver{position:fixed;inset:0;display:none;place-items:center;background:rgba(0,0,0,.75);z-index:10;color:#eaf4ff}
  .overCard{
    width:min(560px,92vw);
    background:#0a1120;border:1px solid #1f2a45;border-radius:18px;
    box-shadow:0 22px 90px rgba(0,0,0,.7);
    padding:20px 22px;text-align:center
  }
  .overTitle{font:900 22px/1.2 system-ui;margin:0 0 8px}
  .overStats{font:600 14px/1.3 system-ui;color:#cfe5ff;margin-bottom:12px}
  .btnRow{display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
  .btn{
    appearance:none;border:none;border-radius:14px;padding:14px 20px;font:800 16px/1 system-ui;cursor:pointer;
    background:linear-gradient(180deg,#18e2ff,#00b2d6);color:#022337;min-width:140px
  }
  .btn--menu{background:linear-gradient(180deg,#ffd08a,#ffb23c);color:#5c2b00}
</style>
</head>
<body>
  <canvas id="game" aria-label="Sign: Retro Descent"></canvas>

  <div id="topUI">
    <div class="bar"><span id="timeFill"></span></div>
    <div class="pill">Lv <span id="levelTxt">1</span></div>
  </div>

  <div id="gameOver">
    <div class="overCard">
      <div class="overTitle">Game Over</div>
      <div id="summary" class="overStats">Score: 0 — Level 1</div>
      <div class="btnRow">
        <button class="btn" id="restartBtn">Restart</button>
        <button class="btn btn--menu" id="menuBtn">Back to Menu</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // World/Canvas
  const WORLD = { w: 360, h: 640 };
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  let scale=1, padX=0, padY=0, dpr=1;
  function resize(){
    dpr = Math.max(1, window.devicePixelRatio||1);
    const cw = window.innerWidth, ch = window.innerHeight;
    canvas.width = cw*dpr; canvas.height = ch*dpr;
    scale = Math.min(canvas.width/WORLD.w, canvas.height/WORLD.h);
    padX = (canvas.width/scale - WORLD.w)/2;
    padY = (canvas.height/scale - WORLD.h)/2;
  }
  window.addEventListener('resize', resize);
  resize();

  // UI refs
  const topUI = document.getElementById('topUI');
  const timeFill = document.getElementById('timeFill');
  const levelTxt = document.getElementById('levelTxt');
  const over = document.getElementById('gameOver');
  const summary = document.getElementById('summary');
  const restartBtn = document.getElementById('restartBtn');
  const menuBtn = document.getElementById('menuBtn');

  // Playfield inside wall
  const FIELD = { x: 10, y: 40, w: WORLD.w-20, h: WORLD.h-50 };
  function layoutFieldGameplay(){
    const r = topUI.getBoundingClientRect();
    const worldPerCss = WORLD.h / (canvas.height/scale);
    const tinyGapCss = 1;
    FIELD.y = Math.max(0, Math.round((r.height + tinyGapCss) * worldPerCss));
    FIELD.x = 10; FIELD.w = WORLD.w - 20; FIELD.h = WORLD.h - FIELD.y - 10;
  }
  function layoutFieldMenu(){
    FIELD.y = 0;
    FIELD.x = 10; FIELD.w = WORLD.w - 20; FIELD.h = WORLD.h - FIELD.y - 10;
  }
  layoutFieldGameplay();

  // Player image auto-load + matte key-out
  let playerImg = null, playerImgProcessed = null;
  (async function preloadPlayer(){
    const tryLoad = (src) => new Promise(res=>{
      const img = new Image(); img.crossOrigin='anonymous';
      img.onload = () => res(img); img.onerror = () => res(null);
      img.src = src + '?v=' + Date.now();
    });
    const img = await tryLoad('player.png') || await tryLoad('./assets/player.png');
    if(img){ playerImg = img; playerImgProcessed = keyOutBlack(img); }
  })();
  function keyOutBlack(img){
    const off = document.createElement('canvas'); off.width = img.width; off.height = img.height;
    const ictx = off.getContext('2d'); ictx.drawImage(img,0,0);
    const id = ictx.getImageData(0,0,off.width,off.height); const d = id.data;
    for(let i=0;i<d.length;i+=4){
      const r=d[i], g=d[i+1], b=d[i+2], a=d[i+3];
      if(a>0 && r<12 && g<12 && b<12){ d[i+3]=0; }
      else if(a>0 && r<24 && g<24 && b<24){ d[i+3]=Math.min(d[i+3],80); }
    }
    ictx.putImageData(id,0,0); return off;
  }

  // Game state
  let gameState = 'menu'; // 'menu' | 'playing'
  let running=true, lastTime=0, advancePending=null;

  const keys = new Set();
  const stick = { active:false, x:0, y:0 };

  const bullets=[], enemies=[], powerups=[], signs=[], effects=[], eBullets=[];
  let boss=null;

  const player = {
    x: 0, y: 0, r: 18,
    vx:0, vy:0, speed: 500, invuln:0,
    lives:3, maxLives:6,
    fireTimer:0, baseFireDelay:0.14,
    spread:0, rapid:0, side:0,
    shieldCharges:0,
    missileTimer:0, missileCD:0.0,
    score:0, level:1, collected:0
  };

  const LEVEL_TIME = 23;
  let levelTime=0;

  // Input
  window.addEventListener('keydown', e=>{
    if(['ArrowLeft','KeyA'].includes(e.code)) keys.add('left');
    if(['ArrowRight','KeyD'].includes(e.code)) keys.add('right');
    if(['ArrowUp','KeyW'].includes(e.code)) keys.add('up');
    if(['ArrowDown','KeyS'].includes(e.code)) keys.add('down');
    if(gameState==='menu' && (e.code==='Enter' || e.code==='Space')) startGame();
  });
  window.addEventListener('keyup', e=>{
    if(['ArrowLeft','KeyA'].includes(e.code)) keys.delete('left');
    if(['ArrowRight','KeyD'].includes(e.code)) keys.delete('right');
    if(['ArrowUp','KeyW'].includes(e.code)) keys.delete('up');
    if(['ArrowDown','KeyS'].includes(e.code)) keys.delete('down');
  });

  canvas.addEventListener('pointerdown', e=>{
    const p = clientToWorld(e.clientX,e.clientY);
    if(gameState==='menu'){
      if(pointInRect(p.x,p.y, startBtn.x, startBtn.y, startBtn.w, startBtn.h)) startGame();
      return;
    }
    stick.active = true; stick.x = p.x; stick.y = p.y;
  });
  canvas.addEventListener('pointermove', e=>{
    if(!stick.active || gameState!=='playing') return;
    const p = clientToWorld(e.clientX,e.clientY);
    stick.x = p.x; stick.y = p.y;
  }, {passive:true});
  ['pointerup','pointercancel','lostpointercapture'].forEach(ev => canvas.addEventListener(ev, ()=>{ if(gameState==='playing') stick.active=false; }));

  restartBtn.onclick = ()=>{ over.style.display='none'; startGame(); };
  menuBtn.onclick = ()=>{ over.style.display='none'; gameState='menu'; running=true; };

  // Start/levels
  function startGame(){
    layoutFieldGameplay();
    gameState='playing';
    topUI.style.visibility='visible';
    Object.assign(player, {
      x: FIELD.x + FIELD.w/2, y: FIELD.y + FIELD.h - 90, vx:0, vy:0, invuln:1.0,
      lives:3, maxLives:6, fireTimer:0, score:0, collected:0, level:1,
      spread:0, rapid:0, side:0, shieldCharges:0, missileTimer:0, missileCD:0
    });
    bullets.length=0; enemies.length=0; powerups.length=0; signs.length=0; effects.length=0; eBullets.length=0;
    boss = null; advancePending=null;
    levelTime=0; timeFill.style.width='0%'; levelTxt.textContent='1';
    running=true;
    enterLevel(1, true);
  }

  function gameOver(){
    running=false;
    summary.textContent = `Score: ${player.score} — Level ${player.level} — Collected Sign: ${player.collected}`;
    over.style.display='grid';
  }

  function isBossLevel(lv){ return lv%5===0 && lv<=20; }
  function isPreBoss(lv){ return lv%5===4; }

  function enterLevel(lv, initial=false){
    player.level = lv;

    if(isPreBoss(lv)){ if(player.shieldCharges<1) player.shieldCharges = 5; }
    else if(!isBossLevel(lv) || initial){ player.shieldCharges = 0; }

    player.lives = 3;

    bullets.length=0; enemies.length=0; eBullets.length=0; powerups.length=0; signs.length=0;
    levelTime=0; timeFill.style.width='0%'; levelTxt.textContent = lv;

    spawnTimer = 0; signTimer = 0; powerTimer = 0;

    if(isBossLevel(lv)){ boss = makeBoss(lv/5); } else { boss=null; }
  }

  function scheduleNextLevel(){
    const n = player.level + 1;
    advancePending = (n>20) ? 'gameover' : n;
  }

  // Spawning (slightly reduced descent in requested ranges)
  let spawnTimer=0, signTimer=0, powerTimer=0;
  function levelSpeedMod(L){
    return ((L>=6 && L<=9) || (L>=11 && L<=14) || (L>=16 && L<=19)) ? 0.9 : 1.0;
  }
  function spawnEnemy(){
    if(isBossLevel(player.level)) return;
    const L = player.level;
    const base = 240 + L*36 + Math.random()*30;
    const speed = base * levelSpeedMod(L);
    const hp = 1 + Math.floor((L-1)/3);
    const typePool = ['crimson1','crimson2','crimson3','gunship','interceptor','bomber','scout','trident','mantis','bulwark','striker'];
    const type = typePool[Math.floor(Math.random()*typePool.length)];
    const x = FIELD.x + 20 + Math.random()*(FIELD.w-40);
    const y = FIELD.y + 8;
    enemies.push({type,x,y,vy:speed,hp,r:15,t:0});
  }
  function spawnSign(){
    const x = FIELD.x + 18 + Math.random()*(FIELD.w-36);
    signs.push({x, y:FIELD.y+8, vy: 190 + Math.random()*40, t:0});
  }
  function spawnPower(){
    const chance = isBossLevel(player.level) ? 0.68 : 0.6;
    if(Math.random()>chance) return;
    let list = ['spread','rapid','side','shield','health'];
    if(isBossLevel(player.level) && Math.random()<0.02) list = ['missile'];
    const type = list[Math.floor(Math.random()*list.length)];
    const x = FIELD.x + 18 + Math.random()*(FIELD.w-36);
    powerups.push({type, x, y:FIELD.y+8, vy: 170, t:0});
  }

  // Bosses
  function makeBoss(index){
    const baseDps = 71;
    const minutes = [1.0, 1.3, 1.6, 2.0][index-1];
    const hp = Math.round(baseDps * 60 * minutes * 1.5);
    const bx = FIELD.x + FIELD.w/2, by = FIELD.y + 74;
    const name = ['Aegis Mk I','Aegis Mk II','Aegis Mk III','Aegis Overlord'][index-1];
    return { index,name,x:bx,y:by,hp,hpMax:hp,t:0,phase:1,fireCd:0.4,patternAngle:0,rot:0 };
  }

  // Background data
  const stars = Array.from({length:120}, ()=>({x:Math.random()*WORLD.w,y:Math.random()*WORLD.h,z:0.3+Math.random()*0.9,p:Math.random()*6}));
  const planets = [
    {x:70, y:140, r:18, col:'#ff9a2a', ring:true, vy:4, seed:1},
    {x:300, y:280, r:14, col:'#7bc8ff', ring:false, vy:5, seed:2}
  ];
  const menuPlanets = [
    {x:FIELD.x+80, y:FIELD.y+150, r:22, col:'#ff9a2a', ring:true, seed:11},
    {x:FIELD.x+260, y:FIELD.y+360, r:26, col:'#7bc8ff', ring:false, seed:22}
  ];

  // Start button rect
  const startBtn = { x: 0, y: 0, w: 0, h: 0 };

  // Loop
  function frame(ts){
    const dt = Math.min(0.033, (ts-lastTime)/1000); lastTime=ts;

    ctx.setTransform(scale,0,0,scale,0,0);
    ctx.clearRect(0,0, canvas.width/scale, canvas.height/scale);
    ctx.save(); ctx.translate(padX, padY);

    if(gameState==='menu'){
      layoutFieldMenu();
      topUI.style.visibility='hidden';
      drawBackground(true);
      drawRustWall();

      ctx.save(); ctx.beginPath(); ctx.rect(FIELD.x, FIELD.y, FIELD.w, FIELD.h); ctx.clip();
      drawStartMenu();
      ctx.restore();

      ctx.restore();
      requestAnimationFrame(frame);
      return;
    }

    // gameplay
    if(!running){ ctx.restore(); requestAnimationFrame(frame); return; }

    if(!isBossLevel(player.level)){
      levelTime += dt; const pct = Math.min(1, levelTime/LEVEL_TIME);
      timeFill.style.width = (pct*100).toFixed(1)+'%';
      if(levelTime>=LEVEL_TIME){ scheduleNextLevel(); }
    }

    ['spread','rapid','side','invuln','missileTimer'].forEach(k=>{ if(player[k]>0) player[k]-=dt; });
    if(player.missileCD>0) player.missileCD-=dt;

    // Movement
    let ax=0, ay=0;
    if(keys.has('left')) ax-=1; if(keys.has('right')) ax+=1;
    if(keys.has('up')) ay-=1; if(keys.has('down')) ay+=1;
    if(stick.active){
      const dx = stick.x - player.x, dy = stick.y - player.y, m = Math.hypot(dx,dy);
      if(m>1){ ax = dx/m; ay = dy/m; const boost = Math.min(1.85, 0.65 + m/34); player.vx = ax*player.speed*boost; player.vy = ay*player.speed*boost; }
      else { player.vx=player.vy=0; }
    }else{ player.vx = ax*player.speed; player.vy = ay*player.speed; }
    player.x = clamp(player.x + player.vx*dt, FIELD.x+12, FIELD.x+FIELD.w-12);
    player.y = clamp(player.y + player.vy*dt, FIELD.y+12, FIELD.y+FIELD.h-12);

    // Fire
    const delay = player.baseFireDelay * (player.rapid>0?0.5:1);
    player.fireTimer -= dt;
    if(player.fireTimer<=0){ player.fireTimer += delay; firePlayer(); }
    if(boss && player.missileTimer>0 && player.missileCD<=0){ player.missileCD = 0.4; fireMissile(); }

    // Spawns
    spawnTimer -= dt; signTimer -= dt; powerTimer -= dt;
    if(!isBossLevel(player.level)){
      const L = player.level;
      const rate = Math.max(0.06, 0.75 - L*0.05);
      if(spawnTimer<=0){
        const batch = 1 + (L>=4?1:0) + (L>=10?1:0);
        for(let i=0;i<batch;i++) spawnEnemy();
        spawnTimer = rate;
      }
    }
    if(signTimer<=0){ spawnSign(); signTimer = 0.8 + Math.random()*0.8; }
    if(powerTimer<=0){ spawnPower(); powerTimer = 3.4 + Math.random()*1.6; }

    // Move enemies
    for(let i=enemies.length-1;i>=0;i--){
      const e=enemies[i]; e.t+=dt; e.y += e.vy*dt;
      if(e.y >= FIELD.y + FIELD.h - 1){ enemies.splice(i,1); continue; }
      if(circleHit(player,e, player.r+e.r-2)){ hitPlayer(); enemies.splice(i,1); }
    }

    // Boss logic
    if(boss){
      boss.t += dt; boss.patternAngle += dt; boss.rot += dt*0.6;
      const hpPct = boss.hp/boss.hpMax;
      boss.phase = hpPct<=0.33?3:(hpPct<=0.66?2:1);
      boss.x = FIELD.x + FIELD.w/2 + Math.sin(boss.t*0.6)*Math.min(110, FIELD.w*0.30);
      boss.fireCd -= dt;
      const fireRate = boss.phase===1?0.5:(boss.phase===2?0.34:0.22);
      if(boss.fireCd<=0){ boss.fireCd=fireRate; bossShoot(boss); }
    }

    // Bullets
    for(let i=bullets.length-1;i>=0;i--){
      const b=bullets[i]; b.x += b.vx*dt; b.y += b.vy*dt;
      if(b.y <= FIELD.y || b.y >= FIELD.y+FIELD.h || b.x<=FIELD.x || b.x>=FIELD.x+FIELD.w){ bullets.splice(i,1); continue; }
      if(!boss){
        for(let j=enemies.length-1;j>=0;j--){
          const e=enemies[j];
          if(circleHit(b,e, e.r+2)){
            e.hp -= (b.isMissile?75:1);
            if(e.hp<=0){ spawnPop(e.x,e.y); enemies.splice(j,1); if(Math.random()<0.5) signs.push({x:e.x,y:e.y,vy:180,t:0}); }
            if(b.isMissile) explodeAt(b.x,b.y);
            bullets.splice(i,1); break;
          }
        }
      }else{
        const hb = bossHitbox(boss);
        if(rectHitPoint(hb, b.x, b.y)){
          const dmg = b.isMissile?75 : (b.dmgBoss||10);
          boss.hp -= dmg;
          if(b.isMissile) explodeAt(b.x,b.y);
          if(boss.hp<=0){ spawnBigExplosion(boss.x,boss.y); scheduleNextLevel(); }
          bullets.splice(i,1);
        }
      }
    }

    // Enemy bullets
    for(let i=eBullets.length-1;i>=0;i--){
      const b=eBullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt;
      if(b.y <= FIELD.y || b.y >= FIELD.y+FIELD.h || b.x<=FIELD.x || b.x>=FIELD.x+FIELD.w){ eBullets.splice(i,1); continue; }
      if(circleHit(player,b, player.r+4)){ eBullets.splice(i,1); hitPlayer(); }
    }

    // Pickups
    for(let i=signs.length-1;i>=0;i--){
      const s=signs[i]; s.t+=dt; s.y += s.vy*dt;
      if(circleHit(player,s, 18)){ player.score += 10; player.collected++; signs.splice(i,1); continue; }
      if(s.y >= FIELD.y+FIELD.h-1) signs.splice(i,1);
    }
    for(let i=powerups.length-1;i>=0;i--){
      const p=powerups[i]; p.t+=dt; p.y += p.vy*dt;
      if(circleHit(player,p, 20)){ applyPower(p.type); powerups.splice(i,1); spawnPop(player.x,player.y); }
      else if(p.y >= FIELD.y+FIELD.h-1) powerups.splice(i,1);
    }

    // Effects
    for(let i=effects.length-1;i>=0;i--){
      const f=effects[i]; f.t+=dt; f.x+=(f.vx||0)*dt; f.y+=(f.vy||0)*dt;
      if(f.t>f.life) effects.splice(i,1);
    }

    // Advance
    if(advancePending){
      if(advancePending==='gameover'){ gameOver(); drawFrame(); return; }
      boss=null; enterLevel(advancePending); advancePending=null;
    }

    // Render
    drawFrame();
    requestAnimationFrame(frame);
  }

  function drawFrame(){
    drawBackground(false);
    drawWatermark(); // updated blue palette + credit placement
    drawRustWall();

    ctx.save(); ctx.beginPath(); ctx.rect(FIELD.x, FIELD.y, FIELD.w, FIELD.h); ctx.clip();

    for(const s of signs) drawSign(s);
    for(const p of powerups) drawPowerup(p);
    for(const e of enemies) drawEnemy(e);
    if(boss) drawBoss(boss);
    drawPlayer();
    drawBullets(bullets, true);
    drawBullets(eBullets, false);

    for(const f of effects){
      const alpha = Math.max(0, 1 - f.t/f.life);
      ctx.globalAlpha = alpha;
      if(f.expl){ drawExplosion(f); }
      else if(f.label){
        ctx.fillStyle='#bfe6ff'; ctx.font='bold 10px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
        const name = {spread:'Spread',rapid:'Rapid',side:'Side',shield:'Shield',health:'Repair',missile:'Missile'}[f.label]||f.label;
        ctx.fillText('+'+name, f.x, f.y);
      }else{
        ctx.fillStyle = f.color || '#fff'; ctx.fillRect(f.x-1.2, f.y-1.2, 2.4, 2.4);
      }
      ctx.globalAlpha = 1;
    }
    ctx.restore();

    drawHUDInside();
    ctx.restore();
  }

  // START MENU (inside wall)
  function drawStartMenu(){
    // Title: Sci-fi metallic blue
    const title = 'Sign Space Adventure';
    const centerX = FIELD.x + FIELD.w/2;
    const margin = 12;
    let size = 46;
    ctx.textAlign='center'; ctx.textBaseline='top';
    while(size>24){
      ctx.font = `900 ${size}px "Trebuchet MS", Arial, system-ui`;
      if(ctx.measureText(title).width <= (FIELD.w - margin*2)) break;
      size--;
    }
    const ty = FIELD.y + 10;

    const metalTitle = ctx.createLinearGradient(FIELD.x, ty, FIELD.x+FIELD.w, ty);
    metalTitle.addColorStop(0.0,'#b4c8ed');
    metalTitle.addColorStop(0.35,'#51a1ff');
    metalTitle.addColorStop(0.7,'#98e7ff');
    metalTitle.addColorStop(1.0,'#dbe8ff');

    ctx.fillStyle = metalTitle;
    ctx.strokeStyle = 'rgba(10,20,35,0.35)';
    ctx.lineWidth = Math.max(1, size*0.05);
    ctx.fillText(title, centerX, ty);
    ctx.strokeText(title, centerX, ty);

    // Title sweep
    const t = performance.now()*0.001, p = (t%7)/7;
    const textW = ctx.measureText(title).width;
    const x1 = centerX - textW/2, x2 = centerX + textW/2;
    const sweep = ctx.createLinearGradient(x1,0,x2,0);
    const band=p, spread=0.06;
    const add = (pos,col)=> sweep.addColorStop(Math.min(1,Math.max(0,pos)), col);
    add(0,'rgba(255,255,255,0.08)');
    add(band-spread,'rgba(255,255,255,0.10)');
    add(band,'rgba(255,255,255,0.55)');
    add(band+spread,'rgba(255,255,255,0.10)');
    add(1,'rgba(255,255,255,0.08)');
    ctx.fillStyle=sweep; ctx.fillText(title, centerX, ty);

    // Description + Legend backdrop (darker for readability)
    const blockX = FIELD.x + 12, blockW = FIELD.w - 24;
    let blockY = ty + size + 10;
    const blockPad = 14;
    const rowH = 40;
    const rows = 6;
    const descH = 36;
    const blockH = blockPad*2 + descH + rows*rowH + 10;
    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = '#0b1220ef';
    roundRect(ctx, blockX, blockY, blockW, blockH, 16); ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.stroke();
    ctx.restore();

    // Description
    ctx.fillStyle='#eaf4ff'; ctx.font='bold 14px system-ui'; ctx.textAlign='center';
    ctx.fillText('Guide your ship through waves of enemies and collect Sign points.', FIELD.x+FIELD.w/2, blockY+blockPad-2);
    ctx.fillText('Use power ups to boost firepower and shields and prepare for bosses.', FIELD.x+FIELD.w/2, blockY+blockPad+16);

    // Legends (kept inside backdrop, scaled if needed)
    const legendList = [
      {k:'spread', label:'Spread', d:'Fires 3-way shots.'},
      {k:'rapid',  label:'Rapid',  d:'Halves shot delay.'},
      {k:'side',   label:'Side Pods', d:'Adds two side cannons.'},
      {k:'shield', label:'Shield', d:'5 charges (20 on boss).'},
      {k:'health', label:'Repair', d:'+1 life, max 6.'},
      {k:'missile',label:'Missile',d:'Boss-only, heavy damage.'}
    ];
    let ly = blockY + blockPad + descH;
    const leftPad = blockX + 14;
    const textLeft = leftPad + 34; // icon box is 28, + padding
    for(const it of legendList){
      // Row subtle bg
      ctx.fillStyle='rgba(255,255,255,0.04)';
      roundRect(ctx, leftPad-6, ly+4, Math.min(240, blockW-28), rowH-8, 10); ctx.fill();

      // Icon inside row, slightly scaled down to ensure no overspill
      drawPowerupIconAt(leftPad, ly + rowH/2, it.k, 0.9);

      // Labels
      ctx.textAlign='left';
      ctx.fillStyle='#dbeeff'; ctx.font='bold 12px system-ui';
      ctx.fillText(it.label, textLeft, ly + 10);
      ctx.fillStyle='#b5c2d6'; ctx.font='11px system-ui';
      ctx.fillText(it.d, textLeft, ly + 24);

      ly += rowH;
    }

    // Player sprite: maximize size without overlapping Start button
    const sprite = playerImgProcessed || playerImg;
    let spriteBottom = ly + 10;
    const buttonBottomMargin = 78;
    if(sprite){
      const iw = sprite.width, ih = sprite.height;
      // Space available between current Y and button top (FIELD.h - buttonBottomMargin)
      const maxBottom = FIELD.y + FIELD.h - buttonBottomMargin - 10;
      const availableH = Math.max(80, maxBottom - spriteBottom);
      const maxW = Math.min(FIELD.w*0.95, FIELD.w - 40);
      const target = Math.min(availableH, maxW);
      const s = target / Math.max(iw, ih);
      const drawH = ih * s;
      ctx.save();
      ctx.translate(FIELD.x + FIELD.w/2, spriteBottom + drawH/2);
      ctx.scale(s, s);
      ctx.drawImage(sprite, -iw/2, -ih/2, iw, ih);
      ctx.restore();
      spriteBottom = spriteBottom + drawH + 8;
    }

    // Start button — metallic blue + continuous sweeping light strip
    const bw = Math.min(240, FIELD.w - 36), bh = 56;
    const bx = FIELD.x + FIELD.w/2 - bw/2;
    const by = Math.min(FIELD.y + FIELD.h - 70, spriteBottom);
    startBtn.x=bx; startBtn.y=by; startBtn.w=bw; startBtn.h=bh;

    // Button body
    ctx.save();
    roundRect(ctx, bx,by,bw,bh,18);
    ctx.clip();
    const metalBtn = ctx.createLinearGradient(bx,by,bx+bw,by+bh);
    metalBtn.addColorStop(0.0,'#bcd8ff');
    metalBtn.addColorStop(0.35,'#45a9ff');
    metalBtn.addColorStop(0.7,'#86d1ff');
    metalBtn.addColorStop(1.0,'#e6f2ff');
    ctx.fillStyle=metalBtn; ctx.fillRect(bx,by,bw,bh);

    // Continuous light band: a bright arc sweeping the full ellipse
    const tt = (performance.now()/1200)%1; // cycle
    const a0 = tt*Math.PI*2, a1 = a0 + Math.PI*0.5; // 90° bright band
    ctx.strokeStyle='rgba(255,255,255,0.85)';
    ctx.lineWidth=10;
    ctx.shadowColor='rgba(255,255,255,0.65)'; ctx.shadowBlur=16;
    ctx.beginPath(); ctx.ellipse(bx+bw/2, by+bh/2, bw*0.48, bh*0.42, 0, a0, a1); ctx.stroke();
    ctx.shadowBlur=0;

    // slight inner sheen
    const sheen = ctx.createLinearGradient(bx,by,bx,by+bh);
    sheen.addColorStop(0,'rgba(255,255,255,0.20)');
    sheen.addColorStop(0.5,'rgba(255,255,255,0.05)');
    sheen.addColorStop(1,'rgba(255,255,255,0.00)');
    ctx.fillStyle=sheen; ctx.fillRect(bx,by,bw,bh);
    ctx.restore();

    // Highly readable START label (white fill, dark outline, glow)
    ctx.font='900 26px "Trebuchet MS", system-ui';
    ctx.textAlign='center'; ctx.textBaseline='top';
    ctx.lineWidth=4; ctx.strokeStyle='#0a1b30';
    ctx.strokeText('START', bx+bw/2, by+12);
    ctx.shadowColor='rgba(255,255,255,0.6)'; ctx.shadowBlur=12;
    ctx.fillStyle='#ffffff';
    ctx.fillText('START', bx+bw/2, by+12);
    ctx.shadowBlur=0;
  }

  // Background and planets (menu: true uses non-overlapping static planets)
  function drawBackground(isMenu){
    const t = performance.now()*0.001;
    // nebula
    const g1 = ctx.createRadialGradient(WORLD.w*0.25, WORLD.h*0.25, 10, WORLD.w*0.25, WORLD.h*0.25, 180);
    g1.addColorStop(0,'rgba(70,120,200,.18)'); g1.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=g1; ctx.fillRect(0,0,WORLD.w,WORLD.h);
    const g2 = ctx.createRadialGradient(WORLD.w*0.75, WORLD.h*0.65, 10, WORLD.w*0.75, WORLD.h*0.65, 200);
    g2.addColorStop(0,'rgba(200,120,70,.16)'); g2.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=g2; ctx.fillRect(0,0,WORLD.w,WORLD.h);
    // stars
    for(const s of stars){
      s.y += 8*s.z*0.016; if (s.y > WORLD.h) s.y -= WORLD.h;
      const tw = 0.3 + 0.35*Math.sin(t*3 + s.p);
      ctx.globalAlpha = 0.35*s.z + tw*0.25;
      ctx.fillStyle = '#b6c9ff';
      ctx.fillRect(s.x, s.y, 1*s.z, 1*s.z);
    }
    ctx.globalAlpha = 1;
    // planets
    if(isMenu){
      for(const p of menuPlanets){
        drawPlanet(p.x, p.y, p.r, p.col, p.seed, p===menuPlanets[0]);
      }
    }else{
      for(const p of planets){
        p.y += p.vy*0.016; if(p.y > WORLD.h + 40){ p.y = -40; }
        drawPlanet(p.x, p.y, p.r, p.col, p.seed, p.ring);
      }
    }
  }

  // Realistic planet with craters and terminator shading
  function drawPlanet(x,y,r,baseCol,seed,ring){
    const light = Math.PI*0.15;
    const lx = Math.cos(light), ly = Math.sin(light);
    const grad = ctx.createRadialGradient(x+r*lx, y+r*ly, r*0.2, x, y, r*1.05);
    grad.addColorStop(0, shade(baseCol, 1.0));
    grad.addColorStop(1, shade(baseCol, 0.35));
    ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();

    const rng = mulberry32(seed);
    const count = Math.max(4, Math.floor(r/4));
    for(let i=0;i<count;i++){
      const ang = rng()*Math.PI*2;
      const rr = r*(0.1 + rng()*0.15);
      const dist = r*(0.2 + rng()*0.6);
      const cx = x + Math.cos(ang)*dist, cy = y + Math.sin(ang)*dist;
      const g = ctx.createRadialGradient(cx - rr*0.3, cy - rr*0.3, rr*0.2, cx, cy, rr);
      g.addColorStop(0, 'rgba(0,0,0,0.15)');
      g.addColorStop(1, 'rgba(0,0,0,0.35)');
      ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx,cy,rr,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.lineWidth=1;
      ctx.beginPath(); ctx.arc(cx,cy,rr*0.9,0,Math.PI*2); ctx.stroke();
    }

    if(ring){
      ctx.save();
      ctx.translate(x,y); ctx.rotate(-0.2);
      ctx.strokeStyle='rgba(255,230,180,.55)';
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.ellipse(0, 2, r+8, r*0.5, 0, 0, Math.PI*2); ctx.stroke();
      ctx.restore();
    }
  }
  function shade(hex, k){ const c = hexToRgb(hex); const f = (v)=> Math.max(0, Math.min(255, Math.round(v*k))); return `rgb(${f(c.r)},${f(c.g)},${f(c.b)})`; }
  function hexToRgb(hex){ const h = hex.replace('#',''); const n = parseInt(h,16); return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 }; }
  function mulberry32(a){ return function(){ let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; } }

  // Watermark + credit (blue sci-fi palette)
  function drawWatermark(){
    const t = performance.now()*0.001; const p = (t%7)/7;
    const x1 = FIELD.x, x2 = FIELD.x+FIELD.w;
    const g = ctx.createLinearGradient(x1, 0, x2, 0);
    const add = (pos,col)=> g.addColorStop(Math.min(1,Math.max(0,pos)), col);
    const band=p, spread=0.04;
    add(0,'rgba(144,194,255,0.06)'); add(band-spread,'rgba(144,194,255,0.06)');
    add(band,'rgba(210,238,255,0.18)'); add(band+spread,'rgba(144,194,255,0.06)'); add(1,'rgba(144,194,255,0.06)');
    const cx = WORLD.w/2, cy = WORLD.h/2;
    ctx.save();
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.font='italic 64px "Trebuchet MS", Arial, sans-serif';
    const word = 'Sign';
    ctx.fillStyle='rgba(144,194,255,0.08)'; ctx.fillText(word, cx, cy);
    ctx.fillStyle=g; ctx.fillText(word, cx, cy);
    const m = ctx.measureText(word);
    const descent = (m.actualBoundingBoxDescent || 20);
    const creditY = cy + descent + 8;
    ctx.font='bold 9px system-ui';
    ctx.fillStyle='rgba(144,194,255,0.08)'; ctx.fillText('Created by Agrigorn', cx, creditY);
    ctx.fillStyle=g; ctx.fillText('Created by Agrigorn', cx, creditY);
    ctx.restore();
  }

  function drawRustWall(){
    ctx.strokeStyle = 'rgba(255,180,80,.25)'; ctx.lineWidth = 10;
    ctx.strokeRect(FIELD.x-3, FIELD.y-3, FIELD.w+6, FIELD.h+6);
    const g = ctx.createLinearGradient(0,FIELD.y,0,FIELD.y+FIELD.h);
    g.addColorStop(0,'#ffb23c'); g.addColorStop(1,'#cc7a17');
    ctx.strokeStyle = g; ctx.lineWidth = 7; ctx.strokeRect(FIELD.x, FIELD.y, FIELD.w, FIELD.h);
    ctx.fillStyle='rgba(255,255,255,.18)';
    for(let x=FIELD.x+10; x<FIELD.x+FIELD.w-10; x+=26){ ctx.fillRect(x, FIELD.y-2, 2,2); ctx.fillRect(x, FIELD.y+FIELD.h, 2,2); }
    for(let y=FIELD.y+10; y<FIELD.y+FIELD.h-10; y+=26){ ctx.fillRect(FIELD.x-2,y,2,2); ctx.fillRect(FIELD.x+FIELD.w,y,2,2); }
  }

  function drawHUDInside(){
    const pad = 6, r = 6;
    let hx = FIELD.x + FIELD.w - pad - r, hy = FIELD.y + pad + 1;
    for(let i=0;i<player.lives;i++) drawHeart(hx - i*(r*2+2), hy, r);
    if(player.shieldCharges>0){
      ctx.fillStyle='#6bd1ff'; ctx.font='10px system-ui'; ctx.textAlign='right'; ctx.textBaseline='top';
      ctx.fillText(`Shield x${player.shieldCharges}`, FIELD.x+FIELD.w-pad, hy+12);
    }
    ctx.fillStyle='#cfe5ff'; ctx.font='10px system-ui'; ctx.textAlign='right'; ctx.textBaseline='top';
    ctx.fillText(`Collected Sign: ${player.collected}`, FIELD.x+FIELD.w-pad, hy+24);

    // Active tags (top-left)
    let bx = FIELD.x + pad, by = FIELD.y + pad + 1;
    const act = [];
    if(player.spread>0) act.push('Sp');
    if(player.rapid>0)  act.push('Rf');
    if(player.side>0)   act.push('Sd');
    if(player.missileTimer>0) act.push('Ms');
    ctx.font='9px system-ui'; ctx.textAlign='left'; ctx.textBaseline='top';
    for(const tag of act){
      ctx.fillStyle='rgba(255,255,255,.12)'; ctx.fillRect(bx,by,16,10);
      ctx.strokeStyle='rgba(255,255,255,.2)'; ctx.strokeRect(bx,by,16,10);
      ctx.fillStyle='#cfe5ff'; ctx.fillText(tag,bx+2,by+1);
      bx += 18;
    }
  }
  function drawHeart(x,y,r){
    ctx.save(); ctx.translate(x,y); ctx.fillStyle='#ff6b81';
    ctx.beginPath(); ctx.moveTo(0, r);
    ctx.bezierCurveTo(r, r-5, r, -r/2, 0, -r/3);
    ctx.bezierCurveTo(-r, -r/2, -r, r-5, 0, r);
    ctx.fill(); ctx.restore();
  }

  function drawPlayer(){
    const px = player.x, py = player.y;
    const sprite = playerImgProcessed || playerImg;
    if(sprite){
      const iw = sprite.width, ih = sprite.height;
      const s = 48 / Math.max(iw, ih);
      ctx.save(); ctx.translate(px, py); ctx.scale(s, s);
      ctx.drawImage(sprite, -iw/2, -ih/2, iw, ih); ctx.restore();
    }else{
      ctx.save(); ctx.translate(px,py);
      ctx.fillStyle='#4fa3a5'; ctx.strokeStyle='#0f2830'; ctx.lineWidth=1.5;
      ctx.beginPath(); ctx.moveTo(22,0); ctx.lineTo(-16,-12); ctx.lineTo(-8,0); ctx.lineTo(-16,12); ctx.closePath(); ctx.fill(); ctx.stroke();
      ctx.restore();
    }
    // Side pods
    if(player.side>0){
      ctx.fillStyle='#ffd96a'; ctx.strokeStyle='#6a540e'; ctx.lineWidth=1.2;
      ctx.beginPath(); ctx.roundRect(px-22,py-7,6,14,3); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.roundRect(px+16,py-7,6,14,3); ctx.fill(); ctx.stroke();
    }
    // Missile racks
    if(player.missileTimer>0){
      ctx.fillStyle='#c7cbd3'; ctx.strokeStyle='#424a58'; ctx.lineWidth=1;
      ctx.beginPath(); ctx.roundRect(px-6,py+10,4,10,1.5); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.roundRect(px+2,py+10,4,10,1.5); ctx.fill(); ctx.stroke();
    }
    // Shield ring
    if(player.shieldCharges>0){
      const pulse = 1 + Math.sin(performance.now()*0.006)*0.06;
      const r = 24 * pulse;
      const g = ctx.createRadialGradient(px,py, r*0.6, px,py, r);
      g.addColorStop(0,'rgba(80,220,255,.25)');
      g.addColorStop(1,'rgba(80,220,255,0)');
      ctx.fillStyle = g; ctx.beginPath(); ctx.arc(px,py,r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(80,220,255,.9)'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(px,py,r*0.85,0,Math.PI*2); ctx.stroke();
    }
  }

  function drawBullets(arr, friendly){
    for(const b of arr){
      if(friendly){
        if(b.isMissile){
          ctx.fillStyle = '#d9e1ff';
          ctx.fillRect(b.x-1.5, b.y-6, 3, 12);
          ctx.fillStyle = '#7c8bb3';
          ctx.fillRect(b.x-4, b.y+2, 3, 5);
          ctx.fillRect(b.x+1, b.y+2, 3, 5);
          ctx.fillStyle = 'rgba(255,170,60,.85)'; ctx.fillRect(b.x-1, b.y+6, 2, 3);
        }else{
          ctx.strokeStyle = '#fffbd1'; ctx.lineWidth = 2;
          ctx.beginPath(); ctx.moveTo(b.x,b.y); ctx.lineTo(b.x, b.y+6); ctx.stroke();
        }
      }else{
        ctx.fillStyle = '#ff6a6a'; ctx.beginPath(); ctx.arc(b.x,b.y,2.4,0,Math.PI*2); ctx.fill();
      }
    }
  }

  // Enemy visuals (teal + crimson) with stronger glow
  function hullTeal(){ return '#2e6f75'; }
  function lineDark(){ return '#0f2830'; }
  function canopy(){ return '#ffb23c'; }
  function lightGlow(alpha){ return `rgba(255,166,49,${alpha})`; }
  function hullRed(){ return '#c43a2b'; }
  function trimRed(){ return '#651c16'; }

  function drawEngineFlame(x,y,wide=6,long=10){
    const t = performance.now()*0.003;
    const len = long + Math.sin(t*9+y)*2;
    const g = ctx.createRadialGradient(x,y+2,1, x,y+len, len);
    g.addColorStop(0,'rgba(255,240,180,.95)');
    g.addColorStop(0.5,'rgba(255,160,40,.85)');
    g.addColorStop(1,'rgba(255,90,10,0)');
    ctx.fillStyle=g; ctx.beginPath(); ctx.ellipse(x, y+len*0.6, wide*0.55, len, 0, 0, Math.PI*2); ctx.fill();
  }

  function drawEnemy(e){
    ctx.save(); ctx.translate(e.x,e.y); ctx.rotate(Math.PI);

    // Stronger pulsing glow underlay
    ctx.save();
    const pulse = 0.45 + 0.35*Math.sin(performance.now()/160 + e.t*3);
    ctx.globalAlpha = pulse;
    const rg = ctx.createRadialGradient(0,0,2, 0,0,22);
    rg.addColorStop(0,'rgba(150,230,255,0.9)');
    rg.addColorStop(1,'rgba(150,230,255,0)');
    ctx.fillStyle = rg; ctx.beginPath(); ctx.arc(0,0,24,0,Math.PI*2); ctx.fill();
    ctx.restore();

    const blink = (Math.sin(e.t*6)+1)*0.5;
    switch(e.type){
      case 'crimson1':{
        ctx.fillStyle=hullRed(); ctx.strokeStyle=trimRed(); ctx.lineWidth=1.6;
        ctx.beginPath(); ctx.roundRect(-11,-16,22,30,6); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-17,2); ctx.lineTo(-8,-6); ctx.lineTo(-8,8); ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(17,2); ctx.lineTo(8,-6); ctx.lineTo(8,8); ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.fillStyle=canopy(); ctx.beginPath(); ctx.ellipse(0,-6,7,5,0,0,Math.PI*2); ctx.fill();
        ctx.fillStyle=hullRed(); ctx.fillRect(-14,4,8,10); ctx.fillRect(6,4,8,10);
        ctx.fillStyle='#ffb23c'; ctx.fillRect(-12,9,4,2); ctx.fillRect(-12,12,4,2); ctx.fillRect(8,9,4,2); ctx.fillRect(8,12,4,2);
        drawEngineFlame(-10,12,4,11); drawEngineFlame(10,12,4,11);
        break;
      }
      case 'crimson2':{
        ctx.fillStyle=hullRed(); ctx.strokeStyle=trimRed(); ctx.lineWidth=1.6;
        ctx.beginPath(); ctx.moveTo(0,-16); ctx.lineTo(12,8); ctx.lineTo(0,12); ctx.lineTo(-12,8); ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.fillStyle='rgba(175,92,217,.9)'; ctx.beginPath(); ctx.arc(-6,-2,1.6,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(6,-2,1.6,0,Math.PI*2); ctx.fill();
        ctx.fillStyle=canopy(); ctx.beginPath(); ctx.ellipse(0,-5,5.5,4.2,0,0,Math.PI*2); ctx.fill();
        drawEngineFlame(0,10,5,12); break;
      }
      case 'crimson3':{
        ctx.fillStyle=hullRed(); ctx.strokeStyle=trimRed(); ctx.lineWidth=1.5;
        ctx.beginPath(); ctx.roundRect(-12,-12,24,24,6); ctx.fill(); ctx.stroke();
        ctx.fillStyle=canopy(); ctx.beginPath(); ctx.ellipse(0,-3,6,4.6,0,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='rgba(175,92,217,.9)'; ctx.fillRect(-3,3,6,2);
        drawEngineFlame(-6,10,3.5,10); drawEngineFlame(6,10,3.5,10); break;
      }
      case 'gunship':{
        ctx.fillStyle=hullTeal(); ctx.strokeStyle=lineDark(); ctx.lineWidth=1.6;
        ctx.beginPath(); ctx.roundRect(-10,-15,20,26,6); ctx.fill(); ctx.stroke();
        ctx.fillStyle=canopy(); ctx.beginPath(); ctx.ellipse(0,-6,6,5,0,0,Math.PI*2); ctx.fill();
        ctx.fillStyle=lightGlow(.5+.4*blink); ctx.fillRect(-6,0,12,2);
        ctx.fillStyle=hullTeal(); ctx.fillRect(-14,2,8,8); ctx.fillRect(6,2,8,8);
        drawEngineFlame(0,12,6,14); break;
      }
      case 'interceptor':{
        ctx.fillStyle=hullTeal(); ctx.strokeStyle=lineDark();
        ctx.beginPath(); ctx.moveTo(0,-16); ctx.lineTo(10,10); ctx.lineTo(-10,10); ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.fillStyle=canopy(); ctx.beginPath(); ctx.ellipse(0,-6,5,4,0,0,Math.PI*2); ctx.fill();
        drawEngineFlame(0,10,5,12); break;
      }
      case 'bomber':{
        ctx.fillStyle=hullTeal(); ctx.strokeStyle=lineDark(); ctx.lineWidth=1.6;
        ctx.beginPath(); ctx.roundRect(-12,-13,24,24,6); ctx.fill(); ctx.stroke();
        ctx.fillStyle=lightGlow(.4+.4*blink); ctx.fillRect(-10,-1,20,3);
        drawEngineFlame(-5,10,4,10); drawEngineFlame(5,10,4,10); break;
      }
      case 'scout':{
        ctx.fillStyle=hullTeal(); ctx.strokeStyle=lineDark();
        ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(10,0); ctx.lineTo(0,12); ctx.lineTo(-10,0); ctx.closePath(); ctx.fill(); ctx.stroke();
        drawEngineFlame(0,10,4,10); break;
      }
      case 'trident':{
        ctx.fillStyle=hullTeal(); ctx.strokeStyle=lineDark();
        ctx.beginPath(); ctx.moveTo(0,-16); ctx.lineTo(8,0); ctx.lineTo(0,6); ctx.lineTo(-8,0); ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.fillStyle=lightGlow(.45+.4*blink); ctx.fillRect(-7,0,14,2);
        drawEngineFlame(-6,8,3,9); drawEngineFlame(6,8,3,9); break;
      }
      case 'mantis':{
        ctx.fillStyle=hullTeal(); ctx.strokeStyle=lineDark();
        ctx.beginPath(); ctx.moveTo(0,-10); ctx.quadraticCurveTo(16,-2,14,8); ctx.lineTo(-14,8); ctx.quadraticCurveTo(-16,-2,0,-10); ctx.fill(); ctx.stroke();
        ctx.fillStyle=canopy(); ctx.beginPath(); ctx.ellipse(0,-4,4.5,3.5,0,0,Math.PI*2); ctx.fill();
        drawEngineFlame(-6,8,3,9); drawEngineFlame(6,8,3,9); break;
      }
      case 'bulwark':{
        ctx.fillStyle=hullTeal(); ctx.strokeStyle=lineDark();
        ctx.beginPath(); ctx.roundRect(-12,-12,24,22,4); ctx.fill(); ctx.stroke();
        ctx.fillStyle=lightGlow(.45+.4*blink); ctx.fillRect(-12,1,24,2);
        drawEngineFlame(0,10,5,12); break;
      }
      case 'striker':{
        ctx.fillStyle=hullTeal(); ctx.strokeStyle=lineDark();
        ctx.beginPath(); ctx.moveTo(0,-14); ctx.lineTo(12,10); ctx.lineTo(0,6); ctx.lineTo(-12,10); ctx.closePath(); ctx.fill(); ctx.stroke();
        drawEngineFlame(0,10,4,11); break;
      }
    }
    ctx.restore();
  }

  // BOSSES — teal motif with rotating side cannons + stronger glow
  function bossHull(){ return '#2e6f75'; }
  function bossTrim(){ return '#12333a'; }
  function drawBoss(b){
    ctx.save(); ctx.translate(b.x,b.y);

    // Strong pulsing aura
    ctx.save();
    const aPulse = 0.6 + 0.25*Math.sin(performance.now()/160 + b.t*2);
    ctx.globalAlpha = aPulse;
    const rg = ctx.createRadialGradient(0,10,0, 0,10,84);
    rg.addColorStop(0,'rgba(90,230,255,0.9)');
    rg.addColorStop(1,'rgba(90,230,255,0)');
    ctx.fillStyle = rg; ctx.beginPath(); ctx.arc(0,10,86,0,Math.PI*2); ctx.fill();
    ctx.restore();

    // main body
    ctx.fillStyle=bossHull(); ctx.strokeStyle=bossTrim(); ctx.lineWidth=2.5;
    const bw = 120, bh = 60;
    ctx.beginPath(); ctx.roundRect(-bw/2,-bh/2,bw,bh,18); ctx.fill(); ctx.stroke();

    // canopy glow
    const glow = 0.5+0.4*Math.sin(b.t*2);
    ctx.fillStyle=`rgba(255,178,60,${0.5+0.5*glow})`;
    ctx.beginPath(); ctx.ellipse(0,-10,20,14,0,0,Math.PI*2); ctx.fill();

    // rotating side cannons
    ctx.save(); ctx.rotate(b.rot*0.6);
    for(const side of [-1,1]){
      ctx.fillStyle=bossHull(); ctx.strokeStyle=bossTrim();
      ctx.beginPath(); ctx.roundRect(side*(bw/2-18)-10,-6,20,12,4); ctx.fill(); ctx.stroke();
      ctx.fillStyle=lightGlow(.8);
      ctx.fillRect(side*(bw/2-6)-2,-3,4,6);
    }
    ctx.restore();

    // engine flames
    drawEngineFlame(-24, bh/2-8, 6, 16);
    drawEngineFlame(24, bh/2-8, 6, 16);

    // boss health bar
    const w=140, h=8; const pct = Math.max(0,b.hp/b.hpMax);
    ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(-w/2, -bh/2-18, w, h);
    const grad = ctx.createLinearGradient(-w/2,0,w/2,0); grad.addColorStop(0,'#ff5d6c'); grad.addColorStop(1,'#ffb23c');
    ctx.fillStyle=grad; ctx.fillRect(-w/2, -bh/2-18, w*pct, h);
    ctx.strokeStyle='rgba(255,255,255,.25)'; ctx.strokeRect(-w/2, -bh/2-18, w, h);

    ctx.restore();
  }
  function bossShoot(b){
    const add = (x,y,vx,vy)=> eBullets.push({x,y,vx,vy});
    if(b.phase===1){
      for(let a=-0.25;a<=0.25;a+=0.25) add(b.x,b.y+30, Math.sin(a)*130, 190);
    }else if(b.phase===2){
      for(let i=-2;i<=2;i++){ const a=i*0.18; add(b.x,b.y+30, Math.sin(a)*150, 210); }
    }else{
      const a=b.patternAngle*4; add(b.x+Math.cos(a)*36,b.y+26, Math.cos(a)*170, 230); add(b.x+Math.cos(a+Math.PI)*36,b.y+26, Math.cos(a+Math.PI)*170, 230);
    }
  }
  function bossHitbox(b){ return {x:b.x-90,y:b.y-50,w:180,h:100}; }
  function rectHitPoint(r, x,y){ return x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h; }

  // Power-ups (crash-safe, timers stack with caps)
  function bumpTimer(prop, add, cap){
    player[prop] = Math.min(cap, Math.max(0, (player[prop]||0) + add));
  }
  function applyPower(type){
    switch(type){
      case 'spread': bumpTimer('spread', 10, 20); break;
      case 'rapid':  bumpTimer('rapid', 10, 20); break;
      case 'side':   bumpTimer('side', 12, 24); break;
      case 'shield': player.shieldCharges = Math.min(30, player.shieldCharges + 5); break;
      case 'health': player.lives = Math.min(player.maxLives, player.lives + 1); break;
      case 'missile':
        bumpTimer('missileTimer', 12, 24);
        player.missileCD = 0;
        break;
    }
    effects.push({x:player.x, y:player.y-24, life:0.8, t:0, label:type});
  }

  function drawPowerup(p){
    ctx.save(); ctx.translate(p.x,p.y);
    drawPowerupIconCore(ctx, p.type);
    ctx.restore();
  }
  function drawPowerupIconCore(c, type){
    c.save();
    switch(type){
      case 'shield':{
        const g = c.createRadialGradient(0,0,2,0,0,10);
        g.addColorStop(0,'#cfe9ff'); g.addColorStop(1,'#3a79c6');
        c.fillStyle=g; c.beginPath(); c.arc(0,0,10,0,Math.PI*2); c.fill();
        c.strokeStyle='#6bd1ff'; c.lineWidth=2; c.beginPath(); c.arc(0,0,10,0,Math.PI*2); c.stroke();
        break;
      }
      case 'rapid':{
        c.fillStyle='#d0f4ff'; c.strokeStyle='#2a4c68'; c.lineWidth=1.5;
        c.beginPath(); c.arc(0,0,10,0,Math.PI*2); c.fill(); c.stroke();
        c.strokeStyle='#3a5e7c';
        for(let i=0;i<6;i++){ const a=i*(Math.PI/3); c.beginPath(); c.moveTo(0,0); c.lineTo(Math.cos(a)*8, Math.sin(a)*8); c.stroke(); }
        break;
      }
      case 'spread':{
        c.fillStyle='#8fffd6';
        for(let i=0;i<3;i++){ const a=i*(2*Math.PI/3); c.beginPath(); c.arc(Math.cos(a)*6, Math.sin(a)*6, 4, 0, Math.PI*2); c.fill(); }
        c.fillStyle='#1c3a32'; c.beginPath(); c.arc(0,0,2,0,Math.PI*2); c.fill();
        break;
      }
      case 'side':{
        c.fillStyle='#ffd96a'; c.strokeStyle='#6a540e'; c.lineWidth=1.2;
        c.beginPath(); c.roundRect(-14,-6,8,12,3); c.fill(); c.stroke();
        c.beginPath(); c.roundRect(6,-6,8,12,3); c.fill(); c.stroke();
        break;
      }
      case 'health':{
        c.fillStyle='#9fe89f'; c.strokeStyle='#1f5a1f'; c.lineWidth=1.2;
        c.beginPath(); c.roundRect(-8,-10,16,20,4); c.fill(); c.stroke();
        c.fillStyle='#165a2a'; c.fillRect(-6,-1,12,2); c.fillRect(-1,-6,2,12);
        break;
      }
      case 'missile':{
        c.fillStyle='#e6ecff'; c.fillRect(-2, -8, 4, 16);
        c.fillStyle='#7c8bb3'; c.fillRect(-4, 4, 3, 5); c.fillRect(1, 4, 3, 5);
        c.fillStyle='#ffb23c'; c.beginPath(); c.moveTo(0,-12); c.lineTo(3,-8); c.lineTo(-3,-8); c.closePath(); c.fill();
        break;
      }
    }
    c.restore();
  }
  function drawPowerupIconAt(x,y,type, scale=1.0){
    ctx.save(); ctx.translate(x,y); ctx.scale(scale,scale);
    ctx.fillStyle='rgba(255,180,80,.12)';
    roundRect(ctx,-14,-14,28,28,6); ctx.fill();
    ctx.translate(-1,0);
    drawPowerupIconCore(ctx, type);
    ctx.restore();
  }

  // Signs
  function drawSign(s){
    ctx.save(); ctx.translate(s.x,s.y);
    ctx.font='italic 12px "Trebuchet MS", Arial, sans-serif';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.shadowColor='rgba(255,166,49,.8)'; ctx.shadowBlur=10;
    ctx.fillStyle='#ff9a2a'; ctx.fillText('Sign',0,0);
    ctx.shadowBlur=0; ctx.restore();
  }

  // Player fire
  function firePlayer(){
    const speed = -460;
    const add = (x,y,vx,vy)=> bullets.push({x,y,vx,vy,dmgBoss:10});
    add(player.x, player.y-18, 0, speed);
    if(player.spread>0){ add(player.x,player.y-18,-105,speed); add(player.x,player.y-18,105,speed); }
    if(player.side>0){ add(player.x-16,player.y-10,0,speed*0.96); add(player.x+16,player.y-10,0,speed*0.96); }
  }
  function fireMissile(){
    if(!boss) return;
    bullets.push({x:player.x-4, y:player.y-8, vx:0, vy:-320, isMissile:true});
    bullets.push({x:player.x+4, y:player.y-8, vx:0, vy:-320, isMissile:true});
  }
  function explodeAt(x,y){
    effects.push({x,y,life:0.6,t:0,expl:true});
    for(let i=0;i<12;i++){
      const a = Math.random()*Math.PI*2;
      effects.push({x,y,vx:Math.cos(a)*120,vy:Math.sin(a)*120,life:0.4,t:0,color:i%2?'#ff9a3c':'#ffd37a'});
    }
  }
  function drawExplosion(f){
    const t = f.t/f.life; const r = 10 + t*26;
    const grad = ctx.createRadialGradient(f.x,f.y,0, f.x,f.y,r);
    grad.addColorStop(0,'rgba(255,240,150,0.95)');
    grad.addColorStop(0.5,'rgba(255,150,60,0.8)');
    grad.addColorStop(1,'rgba(255,80,30,0)');
    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(f.x,f.y,r,0,Math.PI*2); ctx.fill();
  }

  // Utils
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function circleHit(a,b, r){ const dx=(a.x-b.x), dy=(a.y-b.y); return dx*dx+dy*dy <= r*r; }
  function pointInRect(x,y, rx,ry,rw,rh){ return x>=rx && x<=rx+rw && y>=ry && y<=ry+rh; }
  function clientToWorld(cx,cy){
    const rect = canvas.getBoundingClientRect();
    const px = (cx-rect.left) * (canvas.width/rect.width);
    const py = (cy-rect.top) * (canvas.height/rect.height);
    const x = px/scale - padX;
    const y = py/scale - padY;
    return { x, y };
  }

  function loseLife(){ if(player.invuln>0) return; player.lives--; player.invuln=0.7; if(player.lives<=0) gameOver(); }
  function hitPlayer(){
    if(player.invuln>0) return;
    if(player.shieldCharges>0){ player.shieldCharges--; player.invuln=0.5; spawnPop(player.x,player.y); return; }
    loseLife(); spawnPop(player.x,player.y);
  }

  function spawnPop(x,y){ for(let i=0;i<12;i++){ effects.push({x,y,vx:(Math.random()-0.5)*140,vy:(Math.random()-0.8)*160,life:0.4,t:0,color:'#ffd37a'}); } }
  function spawnBigExplosion(x,y){ for(let i=0;i<80;i++){ effects.push({x,y,vx:(Math.random()-0.5)*240,vy:(Math.random()-0.5)*240,life:0.9,t:0,color: i%2? '#ff9a3c':'#ffd37a'}); } }

  // Helpers for UI
  function cap(s){ return s[0].toUpperCase()+s.slice(1); }
  function roundRect(c,x,y,w,h,r){ c.beginPath(); c.moveTo(x+r,y); c.lineTo(x+w-r,y); c.quadraticCurveTo(x+w,y,x+w,y+r); c.lineTo(x+w,y+h-r); c.quadraticCurveTo(x+w,y+h,x+w-r,y+h); c.lineTo(x+r,y+h); c.quadraticCurveTo(x,y+h,x,y+h-r); c.lineTo(x,y+r); c.quadraticCurveTo(x,y,x+r,y); c.closePath(); }

  if(!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      if(typeof r==='number') r={tl:r,tr:r,br:r,bl:r};
      this.beginPath();
      this.moveTo(x+r.tl, y);
      this.lineTo(x+w-r.tr, y);
      this.quadraticCurveTo(x+w, y, x+w, y+r.tr);
      this.lineTo(x+w, y+h-r.br);
      this.quadraticCurveTo(x+w, y+h, x+w-r.br, y+h);
      this.lineTo(x+r.bl, y+h);
      this.quadraticCurveTo(x, y+h, x, y+h-r.bl);
      this.lineTo(x, y+r.tl);
      this.quadraticCurveTo(x, y, x+r.tl, y);
      this.closePath(); return this;
    }
  }

  // Kick off
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
