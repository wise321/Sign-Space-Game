<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Sign — Retro Descent</title>
<style>
  :root{
    --bg:#0a0f1a;
    --wall1:#ffb23c;
    --wall2:#cc7a17;
    --ui:#98e7ff;
    --text:#eaf4ff;
    --accent:#ff9a2a;
    --safe-bottom: env(safe-area-inset-bottom, 0px);
  }
  html,body{
    margin:0;height:100%;background:var(--bg);color:var(--text);
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;overflow:hidden;touch-action:none;
    -webkit-user-select:none;user-select:none;
    padding-bottom:var(--safe-bottom);
  }
  canvas{
    display:block;width:100vw;
    height:100svh; height:100dvh; height:100vh;
    background:linear-gradient(180deg,#0b1324,#070e1c);
  }
  #topUI{position:fixed;top:4px;left:50%;transform:translateX(-50%);
    display:flex;gap:8px;align-items:center;z-index:4;pointer-events:none}
  .bar{width:clamp(160px,70vw,240px);height:12px;border-radius:9px;padding:2px;background:rgba(255,255,255,.06);
    box-shadow:0 0 0 1px rgba(255,255,255,.08) inset, 0 4px 20px rgba(0,0,0,.5);}
  .bar>span{display:block;height:100%;width:0%;border-radius:7px;background:linear-gradient(90deg,#1bd0ff,#7bffcf);
    box-shadow:0 0 12px rgba(60,220,255,.5);transition:width .1s ease-out;}
  .pill{min-width:58px;text-align:center;font-weight:800;font-size:11px;padding:4px 10px;border-radius:999px;
    background:rgba(255,255,255,.08);box-shadow:0 0 0 1px rgba(255,255,255,.12) inset}

  #gameOver{position:fixed;inset:0;display:none;place-items:center;background:rgba(0,0,0,.75);z-index:10;color:#eaf4ff}
  .overCard{
    width:min(560px,92vw);
    background:#0a1120;border:1px solid #1f2a45;border-radius:18px;
    box-shadow:0 22px 90px rgba(0,0,0,.7);
    padding:20px 22px;text-align:center
  }
  .overTitle{font:900 22px/1.2 system-ui;margin:0 0 8px}
  .overStats{font:600 14px/1.3 system-ui;color:#cfe5ff;margin-bottom:12px}
  .btnRow{display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
  .btn{
    appearance:none;border:none;border-radius:14px;padding:14px 20px;font:800 16px/1 system-ui;cursor:pointer;
    background:linear-gradient(180deg,#18e2ff,#00b2d6);color:#022337;min-width:140px
  }
  .btn--menu{background:linear-gradient(180deg,#ffd08a,#ffb23c);color:#5c2b00}
</style>
</head>
<body>
  <canvas id="game" aria-label="Sign: Retro Descent"></canvas>

  <div id="topUI">
    <div class="bar"><span id="timeFill"></span></div>
    <div class="pill">Lv <span id="levelTxt">1</span></div>
  </div>

  <div id="gameOver">
    <div class="overCard">
      <div class="overTitle">Game Over</div>
      <div id="summary" class="overStats">Score: 0 — Level 1</div>
      <div class="btnRow">
        <button class="btn" id="restartBtn">Restart</button>
        <button class="btn btn--menu" id="menuBtn">Back to Menu</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // World/Canvas
  const WORLD = { w: 360, h: 640 };
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  let scale=1, padX=0, padY=0, dpr=1;
  function resize(){
    dpr = Math.max(1, window.devicePixelRatio||1);
    const vw = window.visualViewport?.width || window.innerWidth;
    const vh = window.visualViewport?.height || window.innerHeight;
    canvas.width = vw*dpr; canvas.height = vh*dpr;
    scale = Math.min(canvas.width/WORLD.w, canvas.height/WORLD.h);
    padX = (canvas.width/scale - WORLD.w)/2;
    padY = (canvas.height/scale - WORLD.h)/2;
  }
  window.addEventListener('resize', resize);
  resize();

  // UI refs
  const topUI = document.getElementById('topUI');
  const timeFill = document.getElementById('timeFill');
  const levelTxt = document.getElementById('levelTxt');
  const over = document.getElementById('gameOver');
  const summary = document.getElementById('summary');
  const restartBtn = document.getElementById('restartBtn');
  const menuBtn = document.getElementById('menuBtn');

  // Playfield inside wall (safe bottom inset for mobile)
  const FIELD = { x: 10, y: 40, w: WORLD.w-20, h: WORLD.h-50 };
  function safeBottomCss(){
    const root = getComputedStyle(document.documentElement);
    const v = root.getPropertyValue('--safe-bottom').trim();
    const n = parseFloat(v || '0');
    return isNaN(n)?0:n;
  }
  function layoutFieldGameplay(){
    const r = topUI.getBoundingClientRect();
    const worldPerCss = WORLD.h / (canvas.height/scale);
    const bottomInsetWorld = (safeBottomCss()+4) * worldPerCss;
    FIELD.y = Math.max(0, Math.round((r.height + 1) * worldPerCss));
    FIELD.x = 10; FIELD.w = WORLD.w - 20; FIELD.h = WORLD.h - FIELD.y - 10 - bottomInsetWorld;
  }
  function layoutFieldMenu(){
    const worldPerCss = WORLD.h / (canvas.height/scale);
    const bottomInsetWorld = (safeBottomCss()+4) * worldPerCss;
    FIELD.y = 0; FIELD.x = 10; FIELD.w = WORLD.w - 20; FIELD.h = WORLD.h - FIELD.y - 10 - bottomInsetWorld;
  }
  layoutFieldGameplay();

  // Player image with black key-out
  let playerImg = null, playerImgProcessed = null;
  (async function preloadPlayer(){
    const tryLoad = (src) => new Promise(res=>{
      const img = new Image(); img.crossOrigin='anonymous';
      img.onload = () => res(img); img.onerror = () => res(null);
      img.src = src + '?v=' + Date.now();
    });
    const img = await tryLoad('player.png') || await tryLoad('./assets/player.png');
    if(img){ playerImg = img; playerImgProcessed = keyOutBlack(img); }
  })();
  function keyOutBlack(img){
    const off = document.createElement('canvas'); off.width = img.width; off.height = img.height;
    const ictx = off.getContext('2d'); ictx.drawImage(img,0,0);
    const id = ictx.getImageData(0,0,off.width,off.height); const d = id.data;
    for(let i=0;i<d.length;i+=4){
      const r=d[i], g=d[i+1], b=d[i+2], a=d[i+3];
      if(a>0 && r<12 && g<12 && b<12){ d[i+3]=0; }
      else if(a>0 && r<24 && g<24 && b<24){ d[i+3]=Math.min(d[i+3],80); }
    }
    ictx.putImageData(id,0,0); return off;
  }

  // Game state
  let gameState = 'menu';
  let running=true, lastTime=0, advancePending=null;

  const keys = new Set();
  const stick = { active:false, x:0, y:0 };

  const bullets=[], enemies=[], powerups=[], signs=[], effects=[], eBullets=[];
  let boss=null;

  const player = {
    x: 0, y: 0, r: 18,
    vx:0, vy:0, speed: 500, invuln:0,
    lives:3, maxLives:6,
    fireTimer:0, baseFireDelay:0.14,
    spread:0, rapid:0, side:0,
    shieldCharges:0,
    missileTimer:0, missileCD:0.0,
    score:0, level:1, collected:0
  };

  // Level time reduced to 19 seconds
  const LEVEL_TIME = 19;
  let levelTime=0;

  // Input
  window.addEventListener('keydown', e=>{
    if(['ArrowLeft','KeyA'].includes(e.code)) keys.add('left');
    if(['ArrowRight','KeyD'].includes(e.code)) keys.add('right');
    if(['ArrowUp','KeyW'].includes(e.code)) keys.add('up');
    if(['ArrowDown','KeyS'].includes(e.code)) keys.add('down');
    if(gameState==='menu' && (e.code==='Enter' || e.code==='Space')) startGame();
  });
  window.addEventListener('keyup', e=>{
    if(['ArrowLeft','KeyA'].includes(e.code)) keys.delete('left');
    if(['ArrowRight','KeyD'].includes(e.code)) keys.delete('right');
    if(['ArrowUp','KeyW'].includes(e.code)) keys.delete('up');
    if(['ArrowDown','KeyS'].includes(e.code)) keys.delete('down');
  });

  canvas.addEventListener('pointerdown', e=>{
    const p = clientToWorld(e.clientX,e.clientY);
    if(gameState==='menu'){
      if(pointInRect(p.x,p.y, startBtn.x, startBtn.y, startBtn.w, startBtn.h)) startGame();
      return;
    }
    stick.active = true; stick.x = p.x; stick.y = p.y;
  });
  canvas.addEventListener('pointermove', e=>{
    if(!stick.active || gameState!=='playing') return;
    const p = clientToWorld(e.clientX,e.clientY);
    stick.x = p.x; stick.y = p.y;
  }, {passive:true});
  ['pointerup','pointercancel','lostpointercapture'].forEach(ev => canvas.addEventListener(ev, ()=>{ if(gameState==='playing') stick.active=false; }));

  restartBtn.onclick = ()=>{ over.style.display='none'; startGame(); };
  menuBtn.onclick = ()=>{ over.style.display='none'; gameState='menu'; running=true; };

  // Start/levels
  function startGame(){
    layoutFieldGameplay();
    gameState='playing';
    topUI.style.visibility='visible';
    Object.assign(player, {
      x: FIELD.x + FIELD.w/2, y: FIELD.y + FIELD.h - 90, vx:0, vy:0, invuln:1.0,
      lives:3, maxLives:6, fireTimer:0, score:0, collected:0, level:1,
      spread:0, rapid:0, side:0, shieldCharges:0, missileTimer:0, missileCD:0
    });
    bullets.length=0; enemies.length=0; powerups.length=0; signs.length=0; effects.length=0; eBullets.length=0;
    boss = null; advancePending=null;
    levelTime=0; timeFill.style.width='0%'; levelTxt.textContent='1';
    running=true;
    enterLevel(1, true);
  }

  function gameOver(){
    running=false;
    summary.textContent = `Score: ${player.score} — Level ${player.level} — Collected Sign: ${player.collected}`;
    over.style.display='grid';
  }

  function isBossLevel(lv){ return lv%5===0 && lv<=20; }
  function isPreBoss(lv){ return lv%5===4; }

  function enterLevel(lv, initial=false){
    player.level = lv;
    if(isPreBoss(lv)){ if(player.shieldCharges<1) player.shieldCharges = 5; }
    else if(!isBossLevel(lv) || initial){ player.shieldCharges = 0; }

    player.lives = 3;

    bullets.length=0; enemies.length=0; eBullets.length=0; powerups.length=0; signs.length=0;
    levelTime=0; timeFill.style.width='0%'; levelTxt.textContent = lv;

    spawnTimer = 0; signTimer = 0; powerTimer = 0;

    if(isBossLevel(lv)){ boss = makeBoss(lv/5); } else { boss=null; }
  }

  function scheduleNextLevel(){
    const n = player.level + 1;
    advancePending = (n>20) ? 'gameover' : n;
  }

  // Spawning
  let spawnTimer=0, signTimer=0, powerTimer=0;

  // 13% slower enemies at L>=11 (non-boss)
  function enemySpeedMultiplier(L){ return (L>=11) ? 0.87 : 1.0; }

  // Cap total simultaneous enemies for breathing room
  function maxEnemies(){ return (player.level>=11 ? 10 : 16); }

  // Weighted selection helper
  function weightedChoice(weights){
    const entries = Object.entries(weights);
    const sum = entries.reduce((a,[,w])=>a+w,0);
    let r = Math.random()*sum;
    for(const [k,w] of entries){ if((r-=w)<=0) return k; }
    return entries[entries.length-1][0];
  }
  function choosePowerType(onBoss, level){
    const w = { spread:1, rapid:1, side:1, shield:1, health:1 };
    if(onBoss){ w.shield*=1.08; w.health*=1.08; }
    else if(level>=11){ w.shield*=1.10; w.health*=1.10; }
    return weightedChoice(w);
  }
  function pushPower(type, x){ powerups.push({type, x, y:FIELD.y+8, vy: 170, t:0}); }

  function spawnEnemy(){
    if(isBossLevel(player.level)) return;
    const L = player.level;
    const base = 240 + L*36 + Math.random()*30;
    const speed = base * enemySpeedMultiplier(L);
    const hp = 1 + Math.floor((L-1)/3);
    const types = ['crimson1','crimson2','crimson3','gunship','interceptor','bomber','scout','trident','mantis','bulwark','striker'];
    const type = types[Math.floor(Math.random()*types.length)];
    const x = FIELD.x + 20 + Math.random()*(FIELD.w-40);
    enemies.push({type, x, y:FIELD.y+8, vy:speed, hp, r:15, t:0});
  }
  function spawnSign(){
    const x = FIELD.x + 18 + Math.random()*(FIELD.w-36);
    signs.push({x, y:FIELD.y+8, vy: 190 + Math.random()*40, t:0});
  }
  function spawnPower(){
    const onBoss = isBossLevel(player.level);
    const x = FIELD.x + 18 + Math.random()*(FIELD.w-36);

    // Base chance; +5% extra chance on level >= 11 (both boss and non-boss)
    const base = onBoss ? 0.68 : 0.60;
    const chance = Math.min(0.9, base + (player.level>=11 ? 0.05 : 0));
    if(Math.random() <= chance){
      let type = choosePowerType(onBoss, player.level);
      if(onBoss && Math.random()<0.02) type = 'missile';
      pushPower(type, x);
    }
    // Extra rolls (kept)
    if(onBoss){
      if(Math.random() < 0.08){ pushPower(Math.random()<0.5?'shield':'health', x); }
    }else if(player.level>=11){
      if(Math.random() < 0.10){ pushPower(Math.random()<0.5?'shield':'health', x); }
    }
  }

  // Bosses (HP +10% retained)
  function makeBoss(index){
    const baseDps = 71;
    const minutes = [1.0, 1.3, 1.6, 2.0][index-1];
    const hp = Math.round(baseDps * 60 * minutes * 1.5 * 1.10);
    const bx = FIELD.x + FIELD.w/2, by = FIELD.y + 74;
    const name = ['Centurion Core','Spiral Lancer','Inferno Barrager','Overlord Nexus'][index-1];
    return { index,name,x:bx,y:by,hp,hpMax:hp,t:0,phase:1,fireCd:0.4,patternAngle:0,rot:0,spin:0,sweep:0,low25:false };
  }
  function bossPhaseFromPct(p){ return p<=0.25?4 : p<=0.5?3 : p<=0.75?2 : 1; }
  function bossFierceFactor(b){
    const idxBoost = 1 + 0.18*(b.index-1);
    const phaseBoost = 1 + 0.06*(b.phase-1);
    return idxBoost * phaseBoost;
  }
  function bossFireInterval(b){
    // Faster base; higher bosses are faster; clamp so bosses 2+ never fire too slowly
    const base = (b.phase===1?0.45 : b.phase===2?0.30 : b.phase===3?0.20 : 0.14);
    let interval = base * Math.pow(0.86, (b.index-1));
    if(b.index>1){
      const maxByPhase = [0,0.45,0.30,0.20,0.14];
      interval = Math.min(interval, maxByPhase[b.phase]);
    }
    return Math.max(0.06, interval);
  }

  // Background data
  const stars = Array.from({length:120}, ()=>({x:Math.random()*WORLD.w,y:Math.random()*WORLD.h,z:0.3+Math.random()*0.9,p:Math.random()*6}));
  const planets = [
    {x:70, y:140, r:18, col:'#ff9a2a', ring:true, vy:4, seed:1},
    {x:300, y:280, r:14, col:'#7bc8ff', ring:false, vy:5, seed:2}
  ];
  const menuPlanets = [
    {x:FIELD.x+80, y:FIELD.y+150, r:22, col:'#ff9a2a', ring:true, seed:11},
    {x:FIELD.x+260, y:FIELD.y+360, r:26, col:'#7bc8ff', ring:false, seed:22}
  ];

  // Start button rect
  const startBtn = { x: 0, y: 0, w: 0, h: 0 };

  // Loop
  function frame(ts){
    const dt = Math.min(0.033, (ts-lastTime)/1000); lastTime=ts;

    ctx.setTransform(scale,0,0,scale,0,0);
    ctx.clearRect(0,0, canvas.width/scale, canvas.height/scale);
    ctx.save(); ctx.translate(padX, padY);

    if(gameState==='menu'){
      layoutFieldMenu();
      topUI.style.visibility='hidden';
      drawBackground(true);
      drawRustWall();

      ctx.save(); ctx.beginPath(); ctx.rect(FIELD.x, FIELD.y, FIELD.w, FIELD.h); ctx.clip();
      drawStartMenu();
      ctx.restore();

      ctx.restore();
      requestAnimationFrame(frame);
      return;
    }

    // gameplay
    if(!running){ ctx.restore(); requestAnimationFrame(frame); return; }

    if(!isBossLevel(player.level)){
      levelTime += dt; const pct = Math.min(1, levelTime/LEVEL_TIME);
      timeFill.style.width = (pct*100).toFixed(1)+'%';
      if(levelTime>=LEVEL_TIME){ scheduleNextLevel(); }
    }

    ['spread','rapid','side','invuln','missileTimer'].forEach(k=>{ if(player[k]>0) player[k]-=dt; });
    if(player.missileCD>0) player.missileCD-=dt;

    // Movement
    let ax=0, ay=0;
    if(keys.has('left')) ax-=1; if(keys.has('right')) ax+=1;
    if(keys.has('up')) ay-=1; if(keys.has('down')) ay+=1;
    if(stick.active){
      const dx = stick.x - player.x, dy = stick.y - player.y, m = Math.hypot(dx,dy);
      if(m>1){ ax = dx/m; ay = dy/m; const boost = Math.min(1.85, 0.65 + m/34); player.vx = ax*player.speed*boost; player.vy = ay*player.speed*boost; }
      else { player.vx=player.vy=0; }
    }else{ player.vx = ax*player.speed; player.vy = ay*player.speed; }
    player.x = clamp(player.x + player.vx*dt, FIELD.x+12, FIELD.x+FIELD.w-12);
    player.y = clamp(player.y + player.vy*dt, FIELD.y+12, FIELD.y+FIELD.h-12);

    // Fire
    const delay = player.baseFireDelay * (player.rapid>0?0.5:1);
    player.fireTimer -= dt;
    if(player.fireTimer<=0){ player.fireTimer += delay; firePlayer(); }
    if(boss && player.missileTimer>0 && player.missileCD<=0){ player.missileCD = 0.4; fireMissile(); }

    // Spawns
    spawnTimer -= dt; signTimer -= dt; powerTimer -= dt;
    if(!isBossLevel(player.level)){
      const L = player.level;
      let rate = Math.max(0.06, 0.75 - L*0.05);
      if(L>=11) rate *= 1.35; // much fewer spawns on 11+
      if(spawnTimer<=0){
        let batch = 1 + (L>=4?1:0) + (L>=10?1:0);
        if(L>=11) batch = Math.max(1, batch-1); // reduce batch size
        // spawn only up to cap
        for(let i=0;i<batch && enemies.length<maxEnemies(); i++) spawnEnemy();
        spawnTimer = rate;
      }
    }
    if(signTimer<=0){ spawnSign(); signTimer = 0.8 + Math.random()*0.8; }
    if(powerTimer<=0){ spawnPower(); powerTimer = 3.4 + Math.random()*1.6; }

    // Move enemies
    for(let i=enemies.length-1;i>=0;i--){
      const e=enemies[i]; e.t+=dt; e.y += e.vy*dt;
      if(e.y >= FIELD.y + FIELD.h - 1){ enemies.splice(i,1); continue; }
      if(circleHit(player,e, player.r+e.r-2)){ hitPlayer(); enemies.splice(i,1); }
    }

    // Boss logic
    if(boss){
      boss.t += dt; boss.patternAngle += dt; boss.rot += dt*0.6; boss.spin += dt*1.3; boss.sweep += dt*0.7;
      const hpPct = boss.hp/boss.hpMax;
      boss.phase = bossPhaseFromPct(hpPct);

      // Movement variance
      const amp = [90, 124, 118, 132][boss.index-1] || 100;
      const speed = [0.6, 0.58, 0.75, 0.55][boss.index-1] || 0.6;
      boss.x = FIELD.x + FIELD.w/2 + Math.sin(boss.t*speed)*Math.min(amp, FIELD.w*0.36);

      // 25% HP smoke/fire cue
      if(boss.phase===4){
        if(Math.random()<0.6) spawnSmoke(boss.x + (Math.random()-0.5)*80, boss.y + 24 + (Math.random()-0.5)*30);
        if(Math.random()<0.2) spawnSpark(boss.x + (Math.random()-0.5)*90, boss.y + (Math.random()-0.5)*40);
      }

      boss.fireCd -= dt;
      const fireInterval = bossFireInterval(boss);
      if(boss.fireCd<=0){ boss.fireCd=fireInterval; bossShoot(boss); }
    }

    // Player bullets
    for(let i=bullets.length-1;i>=0;i--){
      const b=bullets[i]; b.x += b.vx*dt; b.y += b.vy*dt;
      if(b.y <= FIELD.y || b.y >= FIELD.y+FIELD.h || b.x<=FIELD.x || b.x>=FIELD.x+FIELD.w){ bullets.splice(i,1); continue; }
      if(!boss){
        for(let j=enemies.length-1;j>=0;j--){
          const e=enemies[j];
          if(circleHit(b,e, e.r+2)){
            e.hp -= (b.isMissile?75:1);
            if(e.hp<=0){ spawnPop(e.x,e.y); enemies.splice(j,1); if(Math.random()<0.5) signs.push({x:e.x,y:e.y,vy:180,t:0}); }
            if(b.isMissile) explodeAt(b.x,b.y);
            bullets.splice(i,1); break;
          }
        }
      }else{
        const hb = bossHitbox(boss);
        if(rectHitPoint(hb, b.x, b.y)){
          const dmg = b.isMissile?75 : (b.dmgBoss||10);
          boss.hp -= dmg;
          if(b.isMissile) explodeAt(b.x,b.y);
          if(boss.hp<=0){ bossDeathExplosion(boss.x,boss.y); scheduleNextLevel(); }
          bullets.splice(i,1);
        }
      }
    }

    // Enemy bullets
    for(let i=eBullets.length-1;i>=0;i--){
      const b=eBullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt;
      if(b.y <= FIELD.y || b.y >= FIELD.y+FIELD.h || b.x<=FIELD.x || b.x>=FIELD.x+FIELD.w){ eBullets.splice(i,1); continue; }
      if(circleHit(player,b, player.r+4)){ eBullets.splice(i,1); hitPlayer(); }
    }

    // Pickups
    for(let i=signs.length-1;i>=0;i--){
      const s=signs[i]; s.t+=dt; s.y += s.vy*dt;
      if(circleHit(player,s, 18)){ player.score += 10; player.collected++; signs.splice(i,1); continue; }
      if(s.y >= FIELD.y+FIELD.h-1) signs.splice(i,1);
    }
    for(let i=powerups.length-1;i>=0;i--){
      const p=powerups[i]; p.t+=dt; p.y += p.vy*dt;
      if(circleHit(player,p, 20)){ applyPower(p.type); powerups.splice(i,1); spawnPop(player.x,player.y); }
      else if(p.y >= FIELD.y+FIELD.h-1) powerups.splice(i,1);
    }

    // Effects
    for(let i=effects.length-1;i>=0;i--){
      const f=effects[i]; f.t+=dt; f.x+=(f.vx||0)*dt; f.y+=(f.vy||0)*dt;
      if(f.t>f.life) effects.splice(i,1);
    }

    // Advance
    if(advancePending){
      if(advancePending==='gameover'){ gameOver(); drawFrame(); return; }
      boss=null; enterLevel(advancePending); advancePending=null;
    }

    // Render
    drawFrame();
    requestAnimationFrame(frame);
  }

  function drawFrame(){
    drawBackground(false);
    drawWatermark();
    drawRustWall();

    ctx.save(); ctx.beginPath(); ctx.rect(FIELD.x, FIELD.y, FIELD.w, FIELD.h); ctx.clip();

    for(const s of signs) drawSign(s);
    for(const p of powerups) drawPowerup(p);
    for(const e of enemies) drawEnemy(e);
    if(boss) drawBoss(boss);
    drawPlayer();
    drawBullets(bullets, true);
    drawBullets(eBullets, false);

    for(const f of effects){
      const alpha = Math.max(0, 1 - f.t/f.life);
      ctx.globalAlpha = alpha;
      if(f.expl){ drawExplosion(f); }
      else if(f.smoke){ drawSmoke(f); }
      else if(f.spark){ drawSpark(f); }
      else if(f.label){
        ctx.fillStyle='#bfe6ff'; ctx.font='bold 10px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
        const name = {spread:'Spread',rapid:'Rapid',side:'Side',shield:'Shield',health:'Repair',missile:'Missile'}[f.label]||f.label;
        ctx.fillText('+'+name, f.x, f.y);
      }else{
        ctx.fillStyle = f.color || '#fff'; ctx.fillRect(f.x-1.2, f.y-1.2, 2.4, 2.4);
      }
      ctx.globalAlpha = 1;
    }
    ctx.restore();

    drawHUDInside();
    ctx.restore();
  }

  // START MENU (inside wall)
  function drawStartMenu(){
    const title = 'Sign Space Adventure';
    const centerX = FIELD.x + FIELD.w/2;
    const margin = 12;
    let size = 46;
    ctx.textAlign='center'; ctx.textBaseline='top';
    while(size>24){
      ctx.font = `900 ${size}px "Trebuchet MS", Arial, system-ui`;
      if(ctx.measureText(title).width <= (FIELD.w - margin*2)) break;
      size--;
    }
    const ty = FIELD.y + 8;

    const metal = ctx.createLinearGradient(0, ty, 0, ty + size*1.2);
    metal.addColorStop(0.0, '#eef3ff'); metal.addColorStop(0.35,'#9aa6b6');
    metal.addColorStop(0.5, '#ffffff'); metal.addColorStop(0.7, '#8a95a6');
    metal.addColorStop(1.0, '#d7dde8');

    ctx.fillStyle = metal;
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = Math.max(1, size*0.045);
    ctx.fillText(title, centerX, ty);
    ctx.strokeText(title, centerX, ty);

    // Stronger sweep band
    const t = performance.now()*0.001;
    const p = (t%7)/7;
    const textW = ctx.measureText(title).width;
    const x1 = centerX - textW/2, x2 = centerX + textW/2;
    const g = ctx.createLinearGradient(x1, 0, x2, 0);
    const band = p, spread = 0.085;
    const add = (pos,col)=> g.addColorStop(Math.min(1,Math.max(0,pos)), col);
    add(0, 'rgba(255,255,255,0.16)');
    add(band-spread, 'rgba(255,255,255,0.16)');
    add(band, 'rgba(255,255,255,0.85)');
    add(band+spread, 'rgba(255,255,255,0.16)');
    add(1, 'rgba(255,255,255,0.16)');
    ctx.fillStyle = g; ctx.fillText(title, centerX, ty);

    // Description
    const wrap = (text, maxWidth) => {
      const words = text.split(' '), lines=[]; let line='';
      ctx.font='14px system-ui';
      for(const w of words){
        const test = line? line+' '+w : w;
        if(ctx.measureText(test).width > maxWidth){ if(line) lines.push(line); line=w; }
        else line=test;
      }
      if(line) lines.push(line);
      return lines;
    };
    const desc = 'Guide your ship through waves of enemies and collect Sign points. Use power ups to boost firepower and shields and prepare for bosses.';
    const descLines = wrap(desc, FIELD.w - 24);
    let ty2 = ty + size + 6;
    ctx.fillStyle='#ffe6c9'; ctx.font='14px system-ui';
    for(const L of descLines){ ctx.fillText(L, centerX, ty2); ty2 += 16; }

    // Legends
    const legend = [
      {k:'spread', label:'Spread', d:'Fires 3-way shots.'},
      {k:'rapid',  label:'Rapid',  d:'Halves shot delay.'},
      {k:'side',   label:'Side Pods', d:'Adds two side cannons.'},
      {k:'shield', label:'Shield', d:'+10 hits (boss +30 hits).'},
      {k:'health', label:'Repair', d:'+1 life, max 6.'},
      {k:'missile',label:'Missile',d:'Boss-only, heavy damage.'}
    ];
    let ly = ty2 + 10;
    const tileW = Math.min(220, FIELD.w*0.60);
    const tileX = FIELD.x + 12;
    ctx.textAlign='left';
    for(const it of legend){
      ctx.fillStyle = 'rgba(0,0,0,0.28)';
      roundRect(ctx, tileX, ly, tileW, 36, 10); ctx.fill();
      ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.lineWidth=1; ctx.stroke();

      const iconX = tileX + 26;
      const iconY = ly + 18;
      drawPowerupIconAt(iconX, iconY, it.k);

      const textLeft = iconX + 20;
      ctx.fillStyle='rgba(0,0,0,0.38)';
      roundRect(ctx, textLeft-6, ly+6, tileW - (textLeft - tileX) - 8, 24, 6); ctx.fill();

      ctx.fillStyle='#ffe6c9'; ctx.font='bold 12px system-ui';
      ctx.fillText(it.label, textLeft, ly+8);
      ctx.fillStyle='#d9cdb6'; ctx.font='11px system-ui';
      ctx.fillText(it.d, textLeft, ly+20);
      ly += 40;
    }

    // Player sprite (menu) sized to avoid Start overlap
    const sprite = playerImgProcessed || playerImg;
    let spriteBlockBottom = ly + 6;
    const startBottomY = FIELD.y + FIELD.h - 66;
    if(sprite){
      const iw = sprite.width, ih = sprite.height;
      const maxTarget = Math.max(0, startBottomY - ly - 14);
      const target = Math.min(FIELD.w*0.90, maxTarget);
      if(target > 6){
        const s = target / Math.max(iw, ih);
        ctx.save(); ctx.translate(FIELD.x + FIELD.w/2, (ly + 6) + target*0.5);
        ctx.scale(s, s); ctx.drawImage(sprite, -iw/2, -ih/2, iw, ih); ctx.restore();
        spriteBlockBottom = ly + target + 14;
      }
    }

    // Start button + glow
    const bw = 200, bh = 48;
    const bx = FIELD.x + FIELD.w/2 - bw/2;
    const by = Math.min(startBottomY, spriteBlockBottom);
    startBtn.x=bx; startBtn.y=by; startBtn.w=bw; startBtn.h=bh;

    const gbtn = ctx.createLinearGradient(0,by,0,by+bh);
    gbtn.addColorStop(0,'#ffddaa'); gbtn.addColorStop(1,'#ffb23c');
    ctx.fillStyle=gbtn; ctx.strokeStyle='rgba(255,180,90,.6)'; ctx.lineWidth=2;
    roundRect(ctx, bx,by,bw,bh,12); ctx.fill(); ctx.stroke();

    ctx.save();
    ctx.font='900 24px "Trebuchet MS", system-ui';
    ctx.fillStyle = '#612800';
    ctx.textAlign='center';
    ctx.fillText('Start', FIELD.x + FIELD.w/2, by+10);
    ctx.restore();

    drawRotatingGlowAroundRect(bx-12, by-12, bw+24, bh+24, 18, '#ff9a2a');
  }

  // Rotating glow ring
  function drawRotatingGlowAroundRect(x,y,w,h,r,color='#ff9a2a'){
    const t = performance.now()*0.001;
    const P = 2*(w+h) - 8*r + 2*Math.PI*r;
    const dashLen = P*0.34;

    ctx.save();
    ctx.lineWidth = 5.2;
    ctx.strokeStyle = 'rgba(255,154,42,0.26)';
    ctx.shadowBlur = 12; ctx.shadowColor = color;
    roundRect(ctx, x,y,w,h,r); ctx.stroke();

    ctx.setLineDash([dashLen, P-dashLen]);
    ctx.lineDashOffset = -((t*200) % P);
    ctx.strokeStyle = 'rgba(255,170,70,0.95)';
    ctx.shadowBlur = 22;
    ctx.lineWidth = 5.2;
    roundRect(ctx, x,y,w,h,r); ctx.stroke();

    ctx.setLineDash([]);
    ctx.shadowBlur = 28; ctx.globalAlpha = 0.45; ctx.lineWidth = 9;
    roundRect(ctx, x,y,w,h,r); ctx.stroke();
    ctx.globalAlpha = 1; ctx.restore();
  }

  // Background and planets
  function drawBackground(isMenu){
    const t = performance.now()*0.001;
    const g1 = ctx.createRadialGradient(WORLD.w*0.25, WORLD.h*0.25, 10, WORLD.w*0.25, WORLD.h*0.25, 180);
    g1.addColorStop(0,'rgba(70,120,200,.18)'); g1.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=g1; ctx.fillRect(0,0,WORLD.w,WORLD.h);
    const g2 = ctx.createRadialGradient(WORLD.w*0.75, WORLD.h*0.65, 10, WORLD.w*0.75, WORLD.h*0.65, 200);
    g2.addColorStop(0,'rgba(200,120,70,.16)'); g2.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=g2; ctx.fillRect(0,0,WORLD.w,WORLD.h);
    for(const s of stars){
      s.y += 8*s.z*0.016; if (s.y > WORLD.h) s.y -= WORLD.h;
      const tw = 0.3 + 0.35*Math.sin(t*3 + s.p);
      ctx.globalAlpha = 0.35*s.z + tw*0.25;
      ctx.fillStyle = '#b6c9ff';
      ctx.fillRect(s.x, s.y, 1*s.z, 1*s.z);
    }
    ctx.globalAlpha = 1;
    if(isMenu){
      for(const p of menuPlanets){ drawPlanet(p.x, p.y, p.r, p.col, p.seed, p===menuPlanets[0]); }
    }else{
      for(const p of planets){ p.y += p.vy*0.016; if(p.y > WORLD.h + 40){ p.y = -40; } drawPlanet(p.x, p.y, p.r, p.col, p.seed, p.ring); }
    }
  }
  function drawPlanet(x,y,r,baseCol,seed,ring){
    const light = Math.PI*0.15;
    const lx = Math.cos(light), ly = Math.sin(light);
    const grad = ctx.createRadialGradient(x+r*lx, y+r*ly, r*0.2, x, y, r*1.05);
    grad.addColorStop(0, shade(baseCol, 1.0)); grad.addColorStop(1, shade(baseCol, 0.35));
    ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();

    const rng = mulberry32(seed);
    const count = Math.max(4, Math.floor(r/4));
    for(let i=0;i<count;i++){
      const ang = rng()*Math.PI*2;
      const rr = r*(0.1 + rng()*0.15);
      const dist = r*(0.2 + rng()*0.6);
      const cx = x + Math.cos(ang)*dist, cy = y + Math.sin(ang)*dist;
      const g = ctx.createRadialGradient(cx - rr*0.3, cy - rr*0.3, rr*0.2, cx, cy, rr);
      g.addColorStop(0, 'rgba(0,0,0,0.15)'); g.addColorStop(1, 'rgba(0,0,0,0.35)');
      ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx,cy,rr,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.lineWidth=1; ctx.beginPath(); ctx.arc(cx,cy,rr*0.9,0,Math.PI*2); ctx.stroke();
    }

    if(ring){
      ctx.save(); ctx.translate(x,y); ctx.rotate(-0.2);
      ctx.strokeStyle='rgba(255,230,180,.55)'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.ellipse(0, 2, r+8, r*0.5, 0, 0, Math.PI*2); ctx.stroke();
      ctx.restore();
    }
  }
  function shade(hex, k){
    const c = hexToRgb(hex); const f = (v)=> Math.max(0, Math.min(255, Math.round(v*k)));
    return `rgb(${f(c.r)},${f(c.g)},${f(c.b)})`;
  }
  function hexToRgb(hex){
    const h = hex.replace('#',''); const n = parseInt(h,16);
    return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
  }
  function mulberry32(a){ return function(){ let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; } }

  // Watermark — original fonts, lowered credit to avoid the 'g' tail
  function drawWatermark(){
    const t = performance.now()*0.001; const p = (t%7)/7;
    const x1 = FIELD.x, x2 = FIELD.x+FIELD.w;
    const g = ctx.createLinearGradient(x1, 0, x2, 0);
    const band = p, spread = 0.06;
    const add = (pos,col)=> g.addColorStop(Math.min(1,Math.max(0,pos)), col);
    add(0, 'rgba(255,154,42,0.08)'); add(band-spread,'rgba(255,154,42,0.08)');
    add(band,'rgba(255,214,130,0.28)'); add(band+spread,'rgba(255,154,42,0.08)'); add(1,'rgba(255,154,42,0.08)');

    const cx = WORLD.w/2, cy = WORLD.h/2;
    ctx.save();
    ctx.textAlign='center'; ctx.textBaseline='middle';

    const word = 'Sign';
    ctx.font='italic 77px "Trebuchet MS", Arial, sans-serif';
    ctx.fillStyle='rgba(255,154,42,0.10)'; ctx.fillText(word, cx, cy);
    ctx.fillStyle=g; ctx.fillText(word, cx, cy);

    const m = ctx.measureText(word);
    const descent = (m.actualBoundingBoxDescent || 20);
    const creditY = cy + descent + 28; // lowered extra to clear the 'g' tail
    ctx.font='bold 10px system-ui';
    ctx.fillStyle='rgba(255,154,42,0.10)'; ctx.fillText('Created by Agrigorn', cx, creditY);
    ctx.fillStyle=g; ctx.fillText('Created by Agrigorn', cx, creditY);
    ctx.restore();
  }

  function drawRustWall(){
    ctx.strokeStyle = 'rgba(255,180,80,.25)'; ctx.lineWidth = 10;
    ctx.strokeRect(FIELD.x-3, FIELD.y-3, FIELD.w+6, FIELD.h+6);
    const g = ctx.createLinearGradient(0,FIELD.y,0,FIELD.y+FIELD.h);
    g.addColorStop(0,'#ffb23c'); g.addColorStop(1,'#cc7a17');
    ctx.strokeStyle = g; ctx.lineWidth = 7; ctx.strokeRect(FIELD.x, FIELD.y, FIELD.w, FIELD.h);
    ctx.fillStyle='rgba(255,255,255,.18)';
    for(let x=FIELD.x+10; x<FIELD.x+FIELD.w-10; x+=26){ ctx.fillRect(x, FIELD.y-2, 2,2); ctx.fillRect(x, FIELD.y+FIELD.h, 2,2); }
    for(let y=FIELD.y+10; y<FIELD.y+FIELD.h-10; y+=26){ ctx.fillRect(FIELD.x-2,y,2,2); ctx.fillRect(FIELD.x+FIELD.w,y,2,2); }
  }

  // Upper-right HUD
  function drawHUDInside(){
    const pad = 6;
    let hx = FIELD.x + FIELD.w - pad - 8, hy = FIELD.y + pad + 1;
    const r = 8;
    for(let i=0;i<player.lives;i++) drawHeart(hx - i*(r*2+3), hy, r);

    ctx.textAlign='right'; ctx.textBaseline='top';
    if(player.shieldCharges>0){
      ctx.fillStyle='#6bd1ff'; ctx.font='12px system-ui';
      ctx.fillText(`Shield x${player.shieldCharges}`, FIELD.x+FIELD.w-pad, hy+16);
    }
    ctx.fillStyle='#cfe5ff'; ctx.font='12px system-ui';
    ctx.fillText(`Collected Sign: ${player.collected}`, FIELD.x+FIELD.w-pad, hy+30);

    let bx = FIELD.x + pad, by = FIELD.y + pad + 1;
    const act = [];
    if(player.spread>0) act.push('Sp');
    if(player.rapid>0)  act.push('Rf');
    if(player.side>0)   act.push('Sd');
    if(player.missileTimer>0) act.push('Ms');
    ctx.font='9px system-ui'; ctx.textAlign='left'; ctx.textBaseline='top';
    for(const tag of act){
      ctx.fillStyle='rgba(255,255,255,.12)'; ctx.fillRect(bx,by,16,10);
      ctx.strokeStyle='rgba(255,255,255,.2)'; ctx.strokeRect(bx,by,16,10);
      ctx.fillStyle='#cfe5ff'; ctx.fillText(tag,bx+2,by+1);
      bx += 18;
    }
  }
  function drawHeart(x,y,r){
    ctx.save(); ctx.translate(x,y); ctx.fillStyle='#ff6b81';
    ctx.beginPath(); ctx.moveTo(0, r);
    ctx.bezierCurveTo(r, r-5, r, -r/2, 0, -r/3);
    ctx.bezierCurveTo(-r, -r/2, -r, r-5, 0, r);
    ctx.fill(); ctx.restore();
  }

  function drawPlayer(){
    const px = player.x, py = player.y;
    const sprite = playerImgProcessed || playerImg;
    if(sprite){
      const iw = sprite.width, ih = sprite.height;
      const s = 62 / Math.max(iw, ih); // 30% larger than original 48
      ctx.save(); ctx.translate(px, py); ctx.scale(s, s);
      ctx.drawImage(sprite, -iw/2, -ih/2, iw, ih); ctx.restore();
    }else{
      ctx.save(); ctx.translate(px,py);
      ctx.fillStyle='#4fa3a5'; ctx.strokeStyle='#0f2830'; ctx.lineWidth=1.5;
      ctx.beginPath(); ctx.moveTo(22,0); ctx.lineTo(-16,-12); ctx.lineTo(-8,0); ctx.lineTo(-16,12); ctx.closePath(); ctx.fill(); ctx.stroke();
      ctx.restore();
    }
    if(player.side>0){
      ctx.fillStyle='#ffd96a'; ctx.strokeStyle='#6a540e'; ctx.lineWidth=1.2;
      ctx.beginPath(); ctx.roundRect(px-22,py-7,6,14,3); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.roundRect(px+16,py-7,6,14,3); ctx.fill(); ctx.stroke();
    }
    if(player.missileTimer>0){
      ctx.fillStyle='#c7cbd3'; ctx.strokeStyle='#424a58'; ctx.lineWidth=1;
      ctx.beginPath(); ctx.roundRect(px-6,py+10,4,10,1.5); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.roundRect(px+2,py+10,4,10,1.5); ctx.fill(); ctx.stroke();
    }
    if(player.shieldCharges>0){
      const pulse = 1 + Math.sin(performance.now()*0.006)*0.06;
      const r = 24 * pulse;
      const g = ctx.createRadialGradient(px,py, r*0.6, px,py, r);
      g.addColorStop(0,'rgba(80,220,255,.25)'); g.addColorStop(1,'rgba(80,220,255,0)');
      ctx.fillStyle = g; ctx.beginPath(); ctx.arc(px,py,r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(80,220,255,.9)'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(px,py,r*0.85,0,Math.PI*2); ctx.stroke();
    }
  }

  // Bullets
  function drawBullets(arr, friendly){
    for(const b of arr){
      if(friendly){
        if(b.isMissile){
          ctx.fillStyle = '#d9e1ff'; ctx.fillRect(b.x-1.5, b.y-6, 3, 12);
          ctx.fillStyle = '#7c8bb3'; ctx.fillRect(b.x-4, b.y+2, 3, 5);
          ctx.fillRect(b.x+1, b.y+2, 3, 5);
          ctx.fillStyle = 'rgba(255,170,60,.85)'; ctx.fillRect(b.x-1, b.y+6, 2, 3);
        }else{
          ctx.strokeStyle = '#fffbd1'; ctx.lineWidth = 2;
          ctx.beginPath(); ctx.moveTo(b.x,b.y); ctx.lineTo(b.x, b.y+6); ctx.stroke();
        }
      }else{
        ctx.fillStyle = '#ff6a6a'; ctx.beginPath(); ctx.arc(b.x,b.y,2.4,0,Math.PI*2); ctx.fill();
      }
    }
  }

  // Enemies (brighter lights retained)
  function hullTeal(){ return '#2e6f75'; }
  function lineDark(){ return '#0f2830'; }
  function canopy(){ return '#ffb23c'; }
  function lightGlow(alpha){ return `rgba(255,166,49,${Math.min(1, alpha*1.25)})`; }
  function hullRed(){ return '#c43a2b'; }
  function trimRed(){ return '#651c16'; }
  function withGlow(draw, color='#ff9a2a', blur=12){ ctx.save(); ctx.shadowColor=color; ctx.shadowBlur=blur; draw(); ctx.restore(); }

  function drawEngineFlame(x,y,wide=6,long=10){
    const t = performance.now()*0.003;
    const len = long + Math.sin(t*9+y)*2;
    const g = ctx.createRadialGradient(x,y+2,1, x,y+len, len);
    g.addColorStop(0,'rgba(255,240,180,.95)');
    g.addColorStop(0.5,'rgba(255,160,40,.85)');
    g.addColorStop(1,'rgba(255,90,10,0)');
    ctx.fillStyle=g; ctx.beginPath(); ctx.ellipse(x, y+len*0.6, wide*0.55, len, 0, 0, Math.PI*2); ctx.fill();
  }

  function drawEnemy(e){
    ctx.save(); ctx.translate(e.x,e.y); ctx.rotate(Math.PI);
    const blink = (Math.sin(e.t*6)+1)*0.5;
    switch(e.type){
      case 'crimson1':{
        ctx.fillStyle=hullRed(); ctx.strokeStyle=trimRed(); ctx.lineWidth=1.6;
        ctx.beginPath(); ctx.roundRect(-11,-16,22,30,6); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-17,2); ctx.lineTo(-8,-6); ctx.lineTo(-8,8); ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(17,2); ctx.lineTo(8,-6); ctx.lineTo(8,8); ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.fillStyle=canopy(); ctx.beginPath(); ctx.ellipse(0,-6,7,5,0,0,Math.PI*2); ctx.fill();
        ctx.fillStyle=hullRed(); ctx.fillRect(-14,4,8,10); ctx.fillRect(6,4,8,10);
        withGlow(()=>{ ctx.fillStyle=lightGlow(.9); ctx.fillRect(-12,9,4,2); ctx.fillRect(-12,12,4,2); ctx.fillRect(8,9,4,2); ctx.fillRect(8,12,4,2); });
        drawEngineFlame(-10,12,4,11); drawEngineFlame(10,12,4,11);
        break;
      }
      case 'crimson2':{
        ctx.fillStyle=hullRed(); ctx.strokeStyle=trimRed(); ctx.lineWidth=1.6;
        ctx.beginPath(); ctx.moveTo(0,-16); ctx.lineTo(12,8); ctx.lineTo(0,12); ctx.lineTo(-12,8); ctx.closePath(); ctx.fill(); ctx.stroke();
        withGlow(()=>{ ctx.fillStyle='rgba(175,92,217,.95)'; ctx.beginPath(); ctx.arc(-6,-2,1.8,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(6,-2,1.8,0,Math.PI*2); ctx.fill(); }, '#b166ff', 10);
        ctx.fillStyle=canopy(); ctx.beginPath(); ctx.ellipse(0,-5,5.5,4.2,0,0,Math.PI*2); ctx.fill();
        drawEngineFlame(0,10,5,12); break;
      }
      case 'crimson3':{
        ctx.fillStyle=hullRed(); ctx.strokeStyle=trimRed(); ctx.lineWidth=1.5;
        ctx.beginPath(); ctx.roundRect(-12,-12,24,24,6); ctx.fill(); ctx.stroke();
        ctx.fillStyle=canopy(); ctx.beginPath(); ctx.ellipse(0,-3,6,4.6,0,0,Math.PI*2); ctx.fill();
        withGlow(()=>{ ctx.fillStyle='rgba(175,92,217,.95)'; ctx.fillRect(-3,3,6,2); }, '#ff9a2a', 10);
        drawEngineFlame(-6,10,3.5,10); drawEngineFlame(6,10,3.5,10); break;
      }
      case 'gunship':{
        ctx.fillStyle=hullTeal(); ctx.strokeStyle=lineDark(); ctx.lineWidth=1.6;
        ctx.beginPath(); ctx.roundRect(-10,-15,20,26,6); ctx.fill(); ctx.stroke();
        ctx.fillStyle=canopy(); ctx.beginPath(); ctx.ellipse(0,-6,6,5,0,0,Math.PI*2); ctx.fill();
        withGlow(()=>{ ctx.fillStyle=lightGlow(.6+.4*blink); ctx.fillRect(-6,0,12,2); });
        ctx.fillStyle=hullTeal(); ctx.fillRect(-14,2,8,8); ctx.fillRect(6,2,8,8);
        drawEngineFlame(0,12,6,14); break;
      }
      case 'interceptor':{
        ctx.fillStyle=hullTeal(); ctx.strokeStyle=lineDark();
        ctx.beginPath(); ctx.moveTo(0,-16); ctx.lineTo(10,10); ctx.lineTo(-10,10); ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.fillStyle=canopy(); ctx.beginPath(); ctx.ellipse(0,-6,5,4,0,0,Math.PI*2); ctx.fill();
        drawEngineFlame(0,10,5,12); break;
      }
      case 'bomber':{
        ctx.fillStyle=hullTeal(); ctx.strokeStyle=lineDark(); ctx.lineWidth=1.6;
        ctx.beginPath(); ctx.roundRect(-12,-13,24,24,6); ctx.fill(); ctx.stroke();
        withGlow(()=>{ ctx.fillStyle=lightGlow(.6+.4*blink); ctx.fillRect(-10,-1,20,3); });
        drawEngineFlame(-5,10,4,10); drawEngineFlame(5,10,4,10); break;
      }
      case 'scout':{
        ctx.fillStyle=hullTeal(); ctx.strokeStyle=lineDark();
        ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(10,0); ctx.lineTo(0,12); ctx.lineTo(-10,0); ctx.closePath(); ctx.fill(); ctx.stroke();
        drawEngineFlame(0,10,4,10); break;
      }
      case 'trident':{
        ctx.fillStyle=hullTeal(); ctx.strokeStyle=lineDark();
        ctx.beginPath(); ctx.moveTo(0,-16); ctx.lineTo(8,0); ctx.lineTo(0,6); ctx.lineTo(-8,0); ctx.closePath(); ctx.fill(); ctx.stroke();
        withGlow(()=>{ ctx.fillStyle=lightGlow(.55+.4*blink); ctx.fillRect(-7,0,14,2); });
        drawEngineFlame(-6,8,3,9); drawEngineFlame(6,8,3,9); break;
      }
      case 'mantis':{
        ctx.fillStyle=hullTeal(); ctx.strokeStyle=lineDark();
        ctx.beginPath(); ctx.moveTo(0,-10); ctx.quadraticCurveTo(16,-2,14,8); ctx.lineTo(-14,8); ctx.quadraticCurveTo(-16,-2,0,-10); ctx.fill(); ctx.stroke();
        ctx.fillStyle=canopy(); ctx.beginPath(); ctx.ellipse(0,-4,4.5,3.5,0,0,Math.PI*2); ctx.fill();
        drawEngineFlame(-6,8,3,9); drawEngineFlame(6,8,3,9); break;
      }
      case 'bulwark':{
        ctx.fillStyle=hullTeal(); ctx.strokeStyle=lineDark();
        ctx.beginPath(); ctx.roundRect(-12,-12,24,22,4); ctx.fill(); ctx.stroke();
        withGlow(()=>{ ctx.fillStyle=lightGlow(.55+.4*blink); ctx.fillRect(-12,1,24,2); });
        drawEngineFlame(0,10,5,12); break;
      }
      case 'striker':{
        ctx.fillStyle=hullTeal(); ctx.strokeStyle=lineDark();
        ctx.beginPath(); ctx.moveTo(0,-14); ctx.lineTo(12,10); ctx.lineTo(0,6); ctx.lineTo(-12,10); ctx.closePath(); ctx.fill(); ctx.stroke();
        drawEngineFlame(0,10,4,11); break;
      }
    }
    ctx.restore();
  }

  // BOSS visuals — larger higher-tier silhouettes with extra wings
  function bossHull(){ return '#1e5257'; }
  function bossHull2(){ return '#2f7a80'; }
  function bossTrim(){ return '#0f2b2f'; }
  function bossPanel(){ return '#ff6c2c'; }
  function bossCore(){ return '#15b1c9'; }

  function drawBoss(b){
    switch(b.index){
      case 1: drawBossVariant(b, {w:118,h:64, fins:true, towers:true, thrusters:3, auxWings:0}); break;
      case 2: drawBossVariant(b, {w:148,h:68, fins:true, towers:false, thrusters:3, wingSweep:18, auxWings:1}); break;
      case 3: drawBossVariant(b, {w:142,h:78, fins:true, towers:true, thrusters:4, wingSweep:12, auxWings:2}); break;
      case 4: drawBossVariant(b, {w:160,h:70, fins:true, towers:true, thrusters:6, coreRings:4, wingSweep:20, auxWings:2}); break;
    }
    // Health bar
    ctx.save(); ctx.translate(b.x,b.y);
    const w=150, h=8; const pct = Math.max(0,b.hp/b.hpMax);
    ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(-w/2, -44, w, h);
    const grad = ctx.createLinearGradient(-w/2,0,w/2,0); grad.addColorStop(0,'#ff5d6c'); grad.addColorStop(1,'#ffb23c');
    ctx.fillStyle=grad; ctx.fillRect(-w/2, -44, w*pct, h);
    ctx.strokeStyle='rgba(255,255,255,.25)'; ctx.strokeRect(-w/2, -44, w, h);
    ctx.restore();
  }

  function drawBossVariant(b, opts){
    const {w,h,fins,towers,thrusters,wingSweep=8,coreRings=2,auxWings=0} = opts;
    ctx.save(); ctx.translate(b.x,b.y);

    ctx.fillStyle=bossHull(); ctx.strokeStyle=bossTrim(); ctx.lineWidth=2.5;
    roundRect(ctx,-w/2,-h/2,w,h,18); ctx.fill(); ctx.stroke();

    ctx.fillStyle=bossPanel();
    ctx.beginPath();
    ctx.moveTo(-w/2+10, -h/2+14); ctx.lineTo(-w/2+10, h/2-10);
    ctx.quadraticCurveTo(-w/2+20+wingSweep, 0, -w/2+10, -h/2+14); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(w/2-10, -h/2+14); ctx.lineTo(w/2-10, h/2-10);
    ctx.quadraticCurveTo(w/2-20-wingSweep, 0, w/2-10, -h/2+14); ctx.fill();

    ctx.fillStyle=bossHull2();
    roundRect(ctx,-w/2+18,-h/2+10,w-36,h-20,12); ctx.fill();

    // extra small side wings
    if(auxWings>0){
      ctx.fillStyle=bossHull();
      for(const side of [-1,1]){
        for(let i=0;i<auxWings;i++){
          const yy = -h/2 + 18 + i*22;
          ctx.beginPath();
          ctx.moveTo(side*(w/2-6), yy);
          ctx.lineTo(side*(w/2+10), yy+10);
          ctx.lineTo(side*(w/2-6), yy+20);
          ctx.closePath(); ctx.fill();
        }
      }
    }

    ctx.save(); ctx.shadowColor='#15b1c9'; ctx.shadowBlur=16;
    ctx.fillStyle='rgba(21,177,201,0.75)'; ctx.beginPath(); ctx.ellipse(0,-h*0.18, w*0.18, h*0.26, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();

    if(towers){
      ctx.fillStyle=bossHull2(); ctx.strokeStyle=bossTrim();
      for(const side of [-1,1]){
        roundRect(ctx, side*(w/2-20)-6, -h/2+4, 12, 24, 4); ctx.fill(); ctx.stroke();
        ctx.save(); ctx.shadowColor='#ffb23c'; ctx.shadowBlur=10; ctx.fillStyle='#ffb23c'; ctx.fillRect(side*(w/2-20)-3, -h/2+26, 6, 4); ctx.restore();
      }
    }
    if(fins){
      ctx.fillStyle=bossHull();
      for(const side of [-1,1]){
        ctx.beginPath();
        ctx.moveTo(side*(w/2-14), -h/2+14);
        ctx.lineTo(side*(w/2-30), -h/2-6);
        ctx.lineTo(side*(w/2-18), -h/2+10);
        ctx.closePath(); ctx.fill();
      }
    }

    for(let i=coreRings;i>=1;i--){
      const r = 10 + i*8;
      ctx.strokeStyle = i%2? '#51d5ef' : '#2a97a9';
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke();
    }
    ctx.save(); ctx.rotate(b.spin*0.6);
    ctx.fillStyle = bossCore(); ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='rgba(255,154,42,0.7)'; ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0,14,0.3,1.2); ctx.closePath(); ctx.fill();
    ctx.restore();

    for(let i=0;i<thrusters;i++){
      const tx = -((thrusters-1)/2)*22 + i*22;
      drawEngineFlame(tx, h/2-10, 6, 16);
    }
    ctx.restore();
  }

  // Boss patterns (enforced multi-shot on bosses 2+ at 75%+)
  function addEBullet(x,y,vx,vy){ eBullets.push({x,y,vx,vy}); }
  function aimVelocity(x1,y1,x2,y2,speed){
    const dx=x2-x1, dy=y2-y1; const m=Math.hypot(dx,dy)||1;
    return {vx:dx/m*speed, vy:dy/m*speed};
  }
  function bossShoot(b){
    switch(b.index){
      case 1: shootCenturionCore(b); break;
      case 2: shootSpiralLancer(b); break;
      case 3: shootInfernoBarrager(b); break;
      case 4: shootOverlordNexus(b); break;
    }
  }
  function bossFierce(b){ return bossFierceFactor(b); }

  function shootCenturionCore(b){
    const F = bossFierce(b);
    const o = aimVelocity(b.x,b.y, player.x,player.y, 230*F);
    for(const off of [-80,0,80]){
      addEBullet(b.x+off*0.06, b.y+26, o.vx + off*0.45*F, o.vy+50*F);
    }
    let total = (b.phase>=2?10:0) + (b.phase>=3?6:0) + (b.phase>=4?8:0);
    total = Math.round(total * (1 + 0.08*(b.index-1)));
    if(total>0){
      const a0 = b.patternAngle*2.2;
      for(let i=0;i<total;i++){
        const a = a0 + i*(Math.PI*2/total);
        const spd = (160 + (b.phase-1)*24 + (i%2?10:0)) * F;
        addEBullet(b.x+Math.cos(a)*18, b.y+Math.sin(a)*10, Math.cos(a)*spd, Math.sin(a)*spd+70*F);
      }
    }
  }
  function shootSpiralLancer(b){
    const F = bossFierce(b);
    // Enforce at least 2 arms from Phase 2 onward (prevents single-shot issue)
    let arms = b.phase>=3? 3 : b.phase>=2? 2 : 1;
    arms = Math.max(b.phase>=2?2:1, Math.min(5, Math.round(arms * (1 + 0.25*(b.index-1)))));
    for(let k=0;k<arms;k++){
      const a = b.patternAngle*4.6 + k*(Math.PI*2/arms);
      const spd = (180 + b.phase*24) * F;
      addEBullet(b.x+Math.cos(a)*22, b.y+18+Math.sin(a)*6, Math.cos(a)*spd, Math.sin(a)*spd+80*F);
    }
    // Side sprays always present from Phase 2+
    if(b.phase>=2){
      const n = Math.max(3, 3 + (b.index>2?2:1));
      for(const side of [-1,1]){
        for(let i=0;i<n;i++){
          const a = (side*0.6) + (i-(n-1)/2)*0.09 + Math.sin(b.sweep)*0.06;
          addEBullet(b.x+side*54, b.y+18, Math.sin(a)*170*F, 220*F);
        }
      }
    }
  }
  function shootInfernoBarrager(b){
    const F = bossFierce(b);
    const columns = (b.phase>=3? 5 : 3) + (b.index>2?2:1);
    for(let i=0;i<columns;i++){
      const x = b.x - (columns-1)*18/2 + i*18;
      addEBullet(x, b.y+30, 0, 250*F);
    }
    const fan = b.phase>=2? (b.phase===2? 6 : 9) : 0;
    const fanN = Math.max(4, fan ? Math.round(fan * (1 + 0.12*(b.index-1))) : 0);
    if(fanN){
      const a0 = -0.7 + Math.sin(b.sweep)*0.45;
      for(let i=0;i<fanN;i++){
        const a = a0 + i*(1.4/(fanN-1));
        const spd = (210 + i*7) * F;
        addEBullet(b.x, b.y+22, Math.sin(a)*spd, Math.cos(a)*-40 + 170*F);
      }
    }
  }
  function shootOverlordNexus(b){
    const F = bossFierce(b);
    const crossBase = b.phase>=2? 6 : 4;
    const cross = Math.max(5, Math.round(crossBase * (1 + 0.18*(b.index-1))));
    const a0 = b.patternAngle*3.2;
    for(let i=0;i<cross;i++){
      const a = a0 + i*(Math.PI/cross)*2;
      addEBullet(b.x, b.y, Math.cos(a)*190*F, Math.sin(a)*190*F+80*F);
    }
    if(b.phase>=3){
      const ringN = 10 + (b.index>2?4:0);
      for(let i=0;i<ringN;i++){
        const a = a0 + i*(Math.PI*2/ringN) + 0.2*(b.phase-3);
        addEBullet(b.x+Math.cos(a)*26, b.y+Math.sin(a)*8, Math.cos(a)*150*F, Math.sin(a)*150*F+70*F);
      }
    }
    if(b.phase>=4){
      const aim = aimVelocity(b.x,b.y, player.x,player.y, 280*F);
      for(const off of [-1,1,0]) addEBullet(b.x+off*12, b.y+22, aim.vx+off*48, aim.vy+28);
    }
  }
  function bossHitbox(b){ return {x:b.x-90,y:b.y-50,w:180,h:100}; }
  function rectHitPoint(r, x,y){ return x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h; }

  // Damage/explosion effects
  function spawnSmoke(x,y){
    effects.push({smoke:true, x, y, vx:(Math.random()-0.5)*30, vy:-40 - Math.random()*60, life:0.9+Math.random()*0.6, t:0, r:6+Math.random()*8});
  }
  function drawSmoke(f){
    const t = f.t/f.life; const r = f.r + t*14;
    const g = ctx.createRadialGradient(f.x,f.y,0, f.x,f.y,r);
    g.addColorStop(0, `rgba(255,150,60,${1-t})`);
    g.addColorStop(0.5, `rgba(180,90,40,${0.8*(1-t)})`);
    g.addColorStop(1, `rgba(90,90,90,${0.6*(1-t)})`);
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(f.x,f.y,r,0,Math.PI*2); ctx.fill();
  }
  function spawnSpark(x,y){
    effects.push({spark:true, x, y, vx:(Math.random()-0.5)*160, vy:(Math.random()-1)*160, life:0.4, t:0});
  }
  function drawSpark(f){
    ctx.strokeStyle='rgba(255,190,90,0.9)'; ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.moveTo(f.x, f.y); ctx.lineTo(f.x - f.vx*0.03, f.y - f.vy*0.03); ctx.stroke();
  }
  function bossDeathExplosion(x,y){
    spawnBigExplosion(x,y);
    for(let i=0;i<8;i++){
      const a = Math.random()*Math.PI*2;
      explodeAt(x + Math.cos(a)*30, y + Math.sin(a)*20);
    }
  }

  // Power-ups (shield amounts: normal +10 cap10, boss +30 cap30)
  function bumpTimer(prop, add, cap){
    player[prop] = Math.min(cap, Math.max(0, (player[prop]||0) + add));
  }
  function applyPower(type){
    switch(type){
      case 'spread': bumpTimer('spread', 10, 20); break;
      case 'rapid':  bumpTimer('rapid', 10, 20); break;
      case 'side':   bumpTimer('side', 12, 24); break;
      case 'shield': {
        if(isBossLevel(player.level)){
          player.shieldCharges = Math.min(30, player.shieldCharges + 30);
        }else{
          player.shieldCharges = Math.min(10, player.shieldCharges + 10);
        }
        break;
      }
      case 'health': player.lives = Math.min(player.maxLives, player.lives + 1); break;
      case 'missile': bumpTimer('missileTimer', 12, 24); player.missileCD = 0; break;
    }
    effects.push({x:player.x, y:player.y-24, life:0.8, t:0, label:type});
  }

  function drawPowerup(p){
    ctx.save(); ctx.translate(p.x,p.y);
    drawPowerupIconCore(ctx, p.type);
    ctx.restore();
  }
  function drawPowerupIconCore(c, type){
    c.save();
    switch(type){
      case 'shield':{
        const g = c.createRadialGradient(0,0,2,0,0,10);
        g.addColorStop(0,'#cfe9ff'); g.addColorStop(1,'#3a79c6');
        c.fillStyle=g; c.beginPath(); c.arc(0,0,10,0,Math.PI*2); c.fill();
        c.strokeStyle='#6bd1ff'; c.lineWidth=2; c.beginPath(); c.arc(0,0,10,0,Math.PI*2); c.stroke();
        break;
      }
      case 'rapid':{
        c.fillStyle='#d0f4ff'; c.strokeStyle='#2a4c68'; c.lineWidth=1.5;
        c.beginPath(); c.arc(0,0,10,0,Math.PI*2); c.fill(); c.stroke();
        c.strokeStyle='#3a5e7c';
        for(let i=0;i<6;i++){ const a=i*(Math.PI/3); c.beginPath(); c.moveTo(0,0); c.lineTo(Math.cos(a)*8, Math.sin(a)*8); c.stroke(); }
        break;
      }
      case 'spread':{
        c.fillStyle='#8fffd6';
        for(let i=0;i<3;i++){ const a=i*(2*Math.PI/3); c.beginPath(); c.arc(Math.cos(a)*6, Math.sin(a)*6, 4, 0, Math.PI*2); c.fill(); }
        c.fillStyle='#1c3a32'; c.beginPath(); c.arc(0,0,2,0,Math.PI*2); c.fill();
        break;
      }
      case 'side':{
        c.fillStyle='#ffd96a'; c.strokeStyle='#6a540e'; c.lineWidth=1.2;
        c.beginPath(); c.roundRect(-14,-6,8,12,3); c.fill(); c.stroke();
        c.beginPath(); c.roundRect(6,-6,8,12,3); c.fill(); c.stroke();
        break;
      }
      case 'health':{
        c.fillStyle='#9fe89f'; c.strokeStyle='#1f5a1f'; c.lineWidth=1.2;
        c.beginPath(); c.roundRect(-8,-10,16,20,4); c.fill(); c.stroke();
        c.fillStyle='#165a2a'; c.fillRect(-6,-1,12,2); c.fillRect(-1,-6,2,12);
        break;
      }
      case 'missile':{
        c.fillStyle='#e6ecff'; c.fillRect(-2, -8, 4, 16);
        c.fillStyle='#7c8bb3'; c.fillRect(-4, 4, 3, 5); c.fillRect(1, 4, 3, 5);
        c.fillStyle='#ffb23c'; c.beginPath(); c.moveTo(0,-12); c.lineTo(3,-8); c.lineTo(-3,-8); c.closePath(); c.fill();
        break;
      }
    }
    c.restore();
  }
  function drawPowerupIconAt(x,y,type){
    ctx.save(); ctx.translate(x,y);
    ctx.fillStyle='rgba(255,180,80,.12)'; roundRect(ctx,-14,-14,28,28,6); ctx.fill();
    ctx.translate(-1,0); drawPowerupIconCore(ctx, type); ctx.restore();
  }

  function drawSign(s){
    ctx.save(); ctx.translate(s.x,s.y);
    ctx.font='italic 12px "Trebuchet MS", Arial, sans-serif';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.shadowColor='rgba(255,166,49,.8)'; ctx.shadowBlur=10;
    ctx.fillStyle='#ff9a2a'; ctx.fillText('Sign',0,0);
    ctx.shadowBlur=0; ctx.restore();
  }

  function firePlayer(){
    const speed = -460;
    const add = (x,y,vx,vy)=> bullets.push({x,y,vx,vy,dmgBoss:10});
    add(player.x, player.y-18, 0, speed);
    if(player.spread>0){ add(player.x,player.y-18,-105,speed); add(player.x,player.y-18,105,speed); }
    if(player.side>0){ add(player.x-16,player.y-10,0,speed*0.96); add(player.x+16,player.y-10,0,speed*0.96); }
  }
  function fireMissile(){
    if(!boss) return;
    bullets.push({x:player.x-4, y:player.y-8, vx:0, vy:-320, isMissile:true});
    bullets.push({x:player.x+4, y:player.y-8, vx:0, vy:-320, isMissile:true});
  }
  function explodeAt(x,y){
    effects.push({x,y,life:0.6,t:0,expl:true});
    for(let i=0;i<12;i++){
      const a = Math.random()*Math.PI*2;
      effects.push({x,y,vx:Math.cos(a)*120,vy:Math.sin(a)*120,life:0.4,t:0,color:i%2?'#ff9a3c':'#ffd37a'});
    }
  }
  function drawExplosion(f){
    const t = f.t/f.life; const r = 10 + t*26;
    const grad = ctx.createRadialGradient(f.x,f.y,0, f.x,f.y,r);
    grad.addColorStop(0,'rgba(255,240,150,0.95)'); grad.addColorStop(0.5,'rgba(255,150,60,0.8)'); grad.addColorStop(1,'rgba(255,80,30,0)');
    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(f.x,f.y,r,0,Math.PI*2); ctx.fill();
  }

  // Utils
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function circleHit(a,b, r){ const dx=(a.x-b.x), dy=(a.y-b.y); return dx*dx+dy*dy <= r*r; }
  function pointInRect(x,y, rx,ry,rw,rh){ return x>=rx && x<=rx+rw && y>=ry && y<=ry+rh; }
  function clientToWorld(cx,cy){
    const rect = canvas.getBoundingClientRect();
    const px = (cx-rect.left) * (canvas.width/rect.width);
    const py = (cy-rect.top) * (canvas.height/rect.height);
    const x = px/scale - padX; const y = py/scale - padY;
    return { x, y };
  }

  function loseLife(){ if(player.invuln>0) return; player.lives--; player.invuln=0.7; if(player.lives<=0) gameOver(); }
  function hitPlayer(){
    if(player.invuln>0) return;
    if(player.shieldCharges>0){ player.shieldCharges--; player.invuln=0.5; spawnPop(player.x,player.y); return; }
    loseLife(); spawnPop(player.x,player.y);
  }

  function spawnPop(x,y){ for(let i=0;i<12;i++){ effects.push({x,y,vx:(Math.random()-0.5)*140,vy:(Math.random()-0.8)*160,life:0.4,t:0,color:'#ffd37a'}); } }
  function spawnBigExplosion(x,y){ for(let i=0;i<120;i++){ effects.push({x,y,vx:(Math.random()-0.5)*260,vy:(Math.random()-0.5)*260,life:0.95,t:0,color: i%2? '#ff9a3c':'#ffd37a'}); } }

  // Path helper
  function roundRect(c,x,y,w,h,r){ c.beginPath(); c.moveTo(x+r,y); c.lineTo(x+w-r,y); c.quadraticCurveTo(x+w,y,x+w,y+r); c.lineTo(x+w,y+h-r); c.quadraticCurveTo(x+w,y+h,x+w-r,y+h); c.lineTo(x+r,y+h); c.quadraticCurveTo(x,y+h,x,y+h-r); c.lineTo(x,y+r); c.quadraticCurveTo(x,y,x+r,y); c.closePath(); }
  if(!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      if(typeof r==='number') r={tl:r,tr:r,br:r,bl:r};
      this.beginPath();
      this.moveTo(x+r.tl, y);
      this.lineTo(x+w-r.tr, y);
      this.quadraticCurveTo(x+w, y, x+w, y+r.tr);
      this.lineTo(x+w, y+h-r.br);
      this.quadraticCurveTo(x+w, y+h, x+w-r.br, y+h);
      this.lineTo(x+r.bl, y+h);
      this.quadraticCurveTo(x, y+h, x, y+h-r.bl);
      this.lineTo(x, y+r.tl);
      this.quadraticCurveTo(x, y, x+r.tl, y);
      this.closePath(); return this;
    }
  }

  // Start loop
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
