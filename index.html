<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Seeing Signs — Minimal Start</title>
<style>
  :root{
    --bg:#0a0f1a;
    --wall1:#ffb23c;
    --wall2:#cc7a17;
    --ui:#98e7ff;
    --text:#eaf4ff;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;overflow:hidden;touch-action:none;
    -webkit-user-select:none;user-select:none}
  canvas{display:block;width:100vw;height:100vh;background:linear-gradient(180deg,#0b1324,#070e1c);}
  /* Top UI (outside wall, compact gap) */
  #topUI{position:fixed;top:4px;left:50%;transform:translateX(-50%);
    display:flex;gap:8px;align-items:center;z-index:4;pointer-events:none}
  .bar{width:clamp(160px,70vw,240px);height:12px;border-radius:9px;padding:2px;background:rgba(255,255,255,.06);
    box-shadow:0 0 0 1px rgba(255,255,255,.08) inset, 0 4px 20px rgba(0,0,0,.5);}
  .bar>span{display:block;height:100%;width:0%;border-radius:7px;background:linear-gradient(90deg,#1bd0ff,#7bffcf);
    box-shadow:0 0 12px rgba(60,220,255,.5);transition:width .1s ease-out;}
  .pill{min-width:58px;text-align:center;font-weight:800;font-size:11px;padding:4px 10px;border-radius:999px;
    background:rgba(255,255,255,.08);box-shadow:0 0 0 1px rgba(255,255,255,.12) inset}
  /* Start overlay — Start button only */
  #start{position:fixed;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.8);z-index:10}
  #playBtn{appearance:none;border:none;border-radius:999px;padding:14px 26px;font-size:18px;font-weight:900;cursor:pointer;
    background:linear-gradient(180deg,#18e2ff,#00b2d6);color:#05222e;box-shadow:0 10px 30px rgba(0,220,255,.25), inset 0 1px 0 rgba(255,255,255,.5)}
  /* Game Over */
  #gameOver{position:fixed;inset:0;display:none;place-items:center;background:rgba(0,0,0,.8);z-index:10;color:#eaf4ff}
  .overCard{background:#0a1120;border:1px solid #1f2a45;border-radius:14px;box-shadow:0 18px 70px rgba(0,0,0,.6);padding:16px 18px;text-align:center}
  .btn{appearance:none;border:none;border-radius:999px;padding:12px 18px;font-weight:800;cursor:pointer;background:linear-gradient(180deg,#18e2ff,#00b2d6);color:#022337;margin:8px}
</style>
</head>
<body>
  <canvas id="game" aria-label="Seeing Signs: Retro Descent"></canvas>

  <!-- Outside (kept tight to the wall) -->
  <div id="topUI">
    <div class="bar"><span id="timeFill"></span></div>
    <div class="pill">Lv <span id="levelTxt">1</span></div>
  </div>

  <!-- Start (only Start button) -->
  <div id="start"><button id="playBtn">Start</button></div>

  <!-- Game Over -->
  <div id="gameOver">
    <div class="overCard">
      <div id="summary" style="margin-bottom:10px;font-weight:700">Score: 0 — Level 1</div>
      <button class="btn" id="restartBtn">Restart</button>
    </div>
  </div>

<script>
(() => {
  // Fixed 360x640 world; scales to any screen; draw everything clipped to the wall
  const WORLD = { w: 360, h: 640 };
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  let scale=1, padX=0, padY=0, dpr=1;
  function resize(){
    dpr = Math.max(1, window.devicePixelRatio||1);
    const cw = window.innerWidth, ch = window.innerHeight;
    canvas.width = cw*dpr; canvas.height = ch*dpr;
    scale = Math.min(canvas.width/WORLD.w, canvas.height/WORLD.h);
    padX = (canvas.width/scale - WORLD.w)/2;
    padY = (canvas.height/scale - WORLD.h)/2;
  }
  window.addEventListener('resize', resize);
  resize();

  // UI
  const topUI = document.getElementById('topUI');
  const timeFill = document.getElementById('timeFill');
  const levelTxt = document.getElementById('levelTxt');
  const start = document.getElementById('start');
  const playBtn = document.getElementById('playBtn');
  const over = document.getElementById('gameOver');
  const summary = document.getElementById('summary');
  const restartBtn = document.getElementById('restartBtn');

  // Playfield (inside wall). Keep gap minimal under top UI.
  const FIELD = { x: 10, y: 40, w: WORLD.w-20, h: WORLD.h-50 };
  function layoutField(){
    const r = topUI.getBoundingClientRect();
    const cssGap = Math.max(2, r.height ? 2 : 0);
    // Approximate world pixels for UI height so the wall tucks right below
    const worldPerCss = WORLD.h / (canvas.height/scale);
    FIELD.y = Math.max(8, Math.round((r.height + cssGap) * worldPerCss));
    FIELD.x = 10; FIELD.w = WORLD.w - 20; FIELD.h = WORLD.h - FIELD.y - 10;
  }
  layoutField();

  // Robust player image auto-load + key out black matting
  let playerImg = null, playerImgProcessed = null, playerImgMissing=false;
  (async function preloadPlayer(){
    const tryLoad = (src) => new Promise(res=>{
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => res(img);
      img.onerror = () => res(null);
      img.src = src + '?v=' + Date.now();
    });
    const img = await tryLoad('player.png') || await tryLoad('./assets/player.png');
    if(!img){ playerImgMissing=true; return; }
    playerImg = img;
    playerImgProcessed = keyOutBlack(img);
  })();

  function keyOutBlack(img){
    const off = document.createElement('canvas'); off.width = img.width; off.height = img.height;
    const ictx = off.getContext('2d');
    ictx.drawImage(img,0,0);
    const id = ictx.getImageData(0,0,off.width,off.height);
    const d = id.data;
    for(let i=0;i<d.length;i+=4){
      const r=d[i], g=d[i+1], b=d[i+2], a=d[i+3];
      // Make near-black fully transparent (helps with black-matted PNGs)
      if(a>0 && r<12 && g<12 && b<12){ d[i+3]=0; }
      // Fade very dark pixels
      else if(a>0 && r<24 && g<24 && b<24){ d[i+3]=Math.min(d[i+3],80); }
    }
    ictx.putImageData(id,0,0);
    return off;
  }

  // State
  let running=false, lastTime=0;
  const keys = new Set();
  const stick = { active:false, x:0, y:0 }; // anchored to ship

  const bullets=[], enemies=[], powerups=[], signs=[], effects=[], eBullets=[];
  let boss=null;

  const player = {
    x: 0, y: 0, r: 16,
    vx:0, vy:0, speed: 480, invuln:0,
    lives:3, maxLives:6,
    fireTimer:0, baseFireDelay:0.14,
    // power states
    spread:0, rapid:0, side:0,
    shieldCharges:0,
    missileTimer:0, missileCD:0.0,
    score:0, level:1, collected:0
  };

  const LEVEL_TIME = 30;
  let levelTime=0;

  // Input (PC)
  window.addEventListener('keydown', e=>{
    if(['ArrowLeft','KeyA'].includes(e.code)) keys.add('left');
    if(['ArrowRight','KeyD'].includes(e.code)) keys.add('right');
    if(['ArrowUp','KeyW'].includes(e.code)) keys.add('up');
    if(['ArrowDown','KeyS'].includes(e.code)) keys.add('down');
  });
  window.addEventListener('keyup', e=>{
    if(['ArrowLeft','KeyA'].includes(e.code)) keys.delete('left');
    if(['ArrowRight','KeyD'].includes(e.code)) keys.delete('right');
    if(['ArrowUp','KeyW'].includes(e.code)) keys.delete('up');
    if(['ArrowDown','KeyS'].includes(e.code)) keys.delete('down');
  });

  // Player-anchored stick (instant direction)
  canvas.addEventListener('pointerdown', e=>{
    const p = clientToWorld(e.clientX,e.clientY);
    stick.active = true; stick.x = p.x; stick.y = p.y;
  });
  canvas.addEventListener('pointermove', e=>{
    if(!stick.active) return;
    const p = clientToWorld(e.clientX,e.clientY);
    stick.x = p.x; stick.y = p.y;
  }, {passive:true});
  ['pointerup','pointercancel','lostpointercapture'].forEach(ev => canvas.addEventListener(ev, ()=>stick.active=false));

  // Start / restart
  playBtn.onclick = ()=>{ startGame(); };
  restartBtn.onclick = ()=>{ over.style.display='none'; startGame(); };

  function startGame(){
    layoutField();
    Object.assign(player, {
      x: FIELD.x + FIELD.w/2, y: FIELD.y + FIELD.h - 90, vx:0, vy:0, invuln:1.0,
      lives:3, maxLives:6, fireTimer:0, score:0, collected:0, level:1,
      spread:0, rapid:0, side:0, shieldCharges:0, missileTimer:0, missileCD:0
    });
    bullets.length=0; enemies.length=0; powerups.length=0; signs.length=0; effects.length=0; eBullets.length=0;
    boss = null;
    levelTime=0; timeFill.style.width='0%'; levelTxt.textContent='1';
    start.style.display='none'; over.style.display='none';
    running=true;
    enterLevel(1);
    lastTime=performance.now();
    requestAnimationFrame(frame);
  }

  function gameOver(){
    running=false;
    summary.textContent = `Score: ${player.score} — Level ${player.level} — Collected Sign: ${player.collected}`;
    over.style.display='grid';
  }

  function isBossLevel(lv){ return lv%5===0 && lv<=20; }
  function enterLevel(lv){
    player.level = lv;
    // Fresh stage lives
    player.lives = 3;
    bullets.length=0; enemies.length=0; eBullets.length=0; powerups.length=0; signs.length=0;
    levelTime=0; timeFill.style.width='0%'; levelTxt.textContent = lv;
    if(isBossLevel(lv)){ boss = makeBoss(lv/5); } else { boss=null; }
  }
  function nextLevel(){
    const n = player.level + 1;
    if(n>20){ gameOver(); return; }
    enterLevel(n);
  }

  // Spawning (inside wall; straight down)
  let spawnTimer=0, signTimer=0, powerTimer=0;
  function spawnEnemy(){
    if(isBossLevel(player.level)) return;
    const L = player.level;
    const speed = 180 + L*24;
    const hp = 1 + Math.floor((L-1)/3);
    const type = ['redRocket','blueRocket','whiteOrange','domeUFO','ringSaucer','diamondShip'][Math.floor(Math.random()*6)];
    const x = FIELD.x + 18 + Math.random()*(FIELD.w-36);
    const y = FIELD.y + 8;
    enemies.push({type,x,y,vy:speed,hp,r:14,t:0});
  }
  function spawnSign(){
    const x = FIELD.x + 18 + Math.random()*(FIELD.w-36);
    signs.push({x, y:FIELD.y+8, vy: 170 + Math.random()*30, t:0});
  }
  function spawnPower(){
    const list = isBossLevel(player.level)
      ? ['spread','rapid','side','shield','health','missile']  // missile only shows up here; low chance handled below
      : ['spread','rapid','side','shield','health'];
    // weight missile very low
    const type = (isBossLevel(player.level) && Math.random()<0.08) ? 'missile' : list[Math.floor(Math.random()*list.length)];
    const x = FIELD.x + 18 + Math.random()*(FIELD.w-36);
    powerups.push({type, x, y:FIELD.y+8, vy: 170, t:0});
  }

  // Bosses — HP tuned for ~1+ minute time-to-kill at 10 dmg per bullet baseline
  // Base DPS estimate: baseFireDelay 0.14s => ~7.14 bullets/s; dmg to boss = 10 => ~71 dps.
  // Boss HP targets (minutes): B1 ~1.0m, B2 ~1.3m, B3 ~1.6m, B4 ~2.0m (before powerups).
  function makeBoss(index){
    const dps = 71;
    const minutes = [1.0, 1.3, 1.6, 2.0][index-1];
    const hp = Math.round(dps * 60 * minutes);
    const bx = FIELD.x + FIELD.w/2, by = FIELD.y + 74;
    const name = ['Overlord Saucer','Mecha-Crab','Tri-Dreadnought','Star Eye Citadel'][index-1];
    return { index,name,x:bx,y:by,hp,hpMax:hp,t:0,phase:1,fireCd:0.4,patternAngle:0 };
  }

  function applyPower(type){
    const DUR = 12;
    if(type==='spread') player.spread = Math.max(player.spread, DUR);
    if(type==='rapid') player.rapid = Math.max(player.rapid, DUR);
    if(type==='side')  player.side  = Math.max(player.side,  DUR);
    if(type==='health') player.lives = Math.min(player.maxLives, player.lives+1);
    if(type==='shield') player.shieldCharges = isBossLevel(player.level) ? 20 : 5; // persists until used up
    if(type==='missile'){ player.missileTimer = Math.max(player.missileTimer, DUR); }
    effects.push({x:player.x,y:player.y-24,vx:0,vy:-30,life:0.8,t:0,label:type});
  }

  // Background: soft stars + subtle nebula + center watermark
  const stars = Array.from({length:100}, ()=>({x:Math.random()*WORLD.w,y:Math.random()*WORLD.h,z:0.3+Math.random()*0.9,p:Math.random()*6}));
  const planets = [
    {x:70, y:140, r:18, col:'#ff9a2a', ring:true, vy:4},
    {x:300, y:280, r:14, col:'#7bc8ff', ring:false, vy:5}
  ];

  function frame(ts){
    if(!running) return;
    const dt = Math.min(0.033, (ts-lastTime)/1000); lastTime=ts;

    // Level timer
    if(!isBossLevel(player.level)){
      levelTime += dt;
      const pct = Math.min(1, levelTime/LEVEL_TIME);
      timeFill.style.width = (pct*100).toFixed(1)+'%';
      if(levelTime>=LEVEL_TIME){ nextLevel(); }
    }

    // Timers decay
    ['spread','rapid','side','invuln','missileTimer'].forEach(k=>{
      if(player[k]>0) player[k]-=dt;
    });
    if(player.missileCD>0) player.missileCD-=dt;

    // Movement: instant, distance‑amplified
    let ax=0, ay=0;
    if(keys.has('left')) ax-=1; if(keys.has('right')) ax+=1;
    if(keys.has('up')) ay-=1; if(keys.has('down')) ay+=1;
    if(stick.active){
      const dx = stick.x - player.x, dy = stick.y - player.y, m = Math.hypot(dx,dy);
      if(m>1){ ax = dx/m; ay = dy/m; const boost = Math.min(1.7, 0.65 + m/36); player.vx = ax*player.speed*boost; player.vy = ay*player.speed*boost; }
      else { player.vx=player.vy=0; }
    }else{ player.vx = ax*player.speed; player.vy = ay*player.speed; }
    player.x = clamp(player.x + player.vx*dt, FIELD.x+12, FIELD.x+FIELD.w-12);
    player.y = clamp(player.y + player.vy*dt, FIELD.y+12, FIELD.y+FIELD.h-12);

    // Auto-fire
    const delay = player.baseFireDelay * (player.rapid>0?0.5:1);
    player.fireTimer -= dt;
    if(player.fireTimer<=0){ player.fireTimer += delay; firePlayer(); }

    // Missile auto-fire during boss power
    if(boss && player.missileTimer>0 && player.missileCD<=0){
      player.missileCD = 0.35; // rapid missiles
      fireMissile();
    }

    // Spawns
    spawnTimer -= dt; signTimer -= dt; powerTimer -= dt;
    if(!isBossLevel(player.level)){
      const rate = Math.max(0.16, 0.95 - player.level*0.05);
      if(spawnTimer<=0){ spawnEnemy(); spawnTimer = rate; }
    }
    if(signTimer<=0){ spawnSign(); signTimer = 1.0 + Math.random()*1.0; }
    if(powerTimer<=0){ if(Math.random()<0.6) spawnPower(); powerTimer = 4 + Math.random()*2; }

    // Enemies (straight down; despawn exactly at wall)
    for(let i=enemies.length-1;i>=0;i--){
      const e=enemies[i]; e.t+=dt; e.y += e.vy*dt;
      if(e.y >= FIELD.y + FIELD.h - 1){ enemies.splice(i,1); continue; }
      if(circleHit(player,e, player.r+e.r-2)){ hitPlayer(); enemies.splice(i,1); }
    }

    // Boss
    if(boss){
      boss.t += dt; boss.patternAngle += dt;
      const hpPct = boss.hp/boss.hpMax;
      boss.phase = hpPct<=0.33?3:(hpPct<=0.66?2:1);
      boss.x = FIELD.x + FIELD.w/2 + Math.sin(boss.t*0.6)*Math.min(110, FIELD.w*0.30);
      boss.fireCd -= dt;
      const fireRate = boss.phase===1?0.5:(boss.phase===2?0.34:0.22);
      if(boss.fireCd<=0){ boss.fireCd=fireRate; bossShoot(boss); }
    }

    // Bullets (clip to wall and despawn at edges)
    for(let i=bullets.length-1;i>=0;i--){
      const b=bullets[i]; b.x += b.vx*dt; b.y += b.vy*dt;
      // Despawn at walls (no visuals outside)
      if(b.y <= FIELD.y || b.y >= FIELD.y+FIELD.h || b.x<=FIELD.x || b.x>=FIELD.x+FIELD.w){ bullets.splice(i,1); continue; }
      if(!boss){
        for(let j=enemies.length-1;j>=0;j--){
          const e=enemies[j];
          if(circleHit(b,e, e.r+2)){
            e.hp -= (b.isMissile?100:1);
            if(e.hp<=0){ spawnPop(e.x,e.y); enemies.splice(j,1); if(Math.random()<0.5) signs.push({x:e.x,y:e.y,vy:175,t:0}); }
            bullets.splice(i,1);
            break;
          }
        }
      }else{
        if(rectHitPoint(bossHitbox(boss), b.x, b.y)){
          const dmg = b.isMissile?100 : (b.dmgBoss||10);
          boss.hp -= dmg;
          if(b.isMissile) explodeAt(b.x,b.y);
          if(boss.hp<=0){ spawnBigExplosion(boss.x,boss.y); boss=null; nextLevel(); }
          bullets.splice(i,1);
        }
      }
    }

    // Boss bullets (despawn at wall)
    for(let i=eBullets.length-1;i>=0;i--){
      const b=eBullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt;
      if(b.y <= FIELD.y || b.y >= FIELD.y+FIELD.h || b.x<=FIELD.x || b.x>=FIELD.x+FIELD.w){ eBullets.splice(i,1); continue; }
      if(circleHit(player,b, player.r+4)){ eBullets.splice(i,1); hitPlayer(); }
    }

    // Signs / Powerups (despawn exactly at bottom wall)
    for(let i=signs.length-1;i>=0;i--){
      const s=signs[i]; s.t+=dt; s.y += s.vy*dt;
      const pickR = 18;
      if(circleHit(player,s, pickR)){ player.score += 10; player.collected++; signs.splice(i,1); continue; }
      if(s.y >= FIELD.y+FIELD.h-1) signs.splice(i,1);
    }
    for(let i=powerups.length-1;i>=0;i--){
      const p=powerups[i]; p.t+=dt; p.y += p.vy*dt;
      const pickR = 20;
      if(circleHit(player,p, pickR)){ applyPower(p.type); powerups.splice(i,1); spawnPop(player.x,player.y); }
      else if(p.y >= FIELD.y+FIELD.h-1) powerups.splice(i,1);
    }

    // Effects
    for(let i=effects.length-1;i>=0;i--){
      const f=effects[i]; f.t+=dt; f.x+=(f.vx||0)*dt; f.y+=(f.vy||0)*dt;
      if(f.t>f.life) effects.splice(i,1);
    }

    // Render (clip to wall so nothing draws outside)
    ctx.setTransform(scale,0,0,scale,0,0);
    ctx.clearRect(0,0, canvas.width/scale, canvas.height/scale);
    ctx.save(); ctx.translate(padX, padY);

    drawBackground(); // under everything

    // Watermark "Sign" (big, faint, centered)
    ctx.save();
    ctx.globalAlpha = 0.06;
    ctx.fillStyle = '#ff9a2a';
    ctx.font = 'bold 64px Trebuchet MS, Arial, sans-serif';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText('Sign', WORLD.w/2, WORLD.h/2);
    ctx.restore();

    drawRustWall();

    // clip region = inside wall
    ctx.save();
    ctx.beginPath(); ctx.rect(FIELD.x, FIELD.y, FIELD.w, FIELD.h); ctx.clip();

    // Signs and powerups
    for(const s of signs) drawSign(s);
    for(const p of powerups) drawPowerup(p);

    // Enemies
    for(const e of enemies) drawEnemy(e);

    // Boss
    if(boss) drawBoss(boss);

    // Player
    drawPlayer();

    // Bullets
    drawBullets(bullets, true);
    drawBullets(eBullets, false);

    // Effects (particles/labels)
    for(const f of effects){
      const alpha = Math.max(0, 1 - f.t/f.life);
      ctx.globalAlpha = alpha;
      if(f.expl){ drawExplosion(f); }
      else if(f.label){
        ctx.fillStyle='#bfe6ff'; ctx.font='bold 10px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
        const name = {spread:'Spread',rapid:'Rapid',side:'Side',shield:'Shield',health:'Health',missile:'Missile'}[f.label]||f.label;
        ctx.fillText('+'+name, f.x, f.y);
      }else{
        ctx.fillStyle = f.color || '#fff'; ctx.fillRect(f.x-1.2, f.y-1.2, 2.4, 2.4);
      }
      ctx.globalAlpha = 1;
    }
    ctx.restore(); // end clip

    // HUD inside wall (hearts + mini tags)
    drawHUDInside();

    ctx.restore();
    requestAnimationFrame(frame);
  }

  // Drawing helpers ------------------------------------------------
  function drawBackground(){
    const t = performance.now()*0.001;
    // very soft nebula
    const g1 = ctx.createRadialGradient(WORLD.w*0.25, WORLD.h*0.25, 10, WORLD.w*0.25, WORLD.h*0.25, 180);
    g1.addColorStop(0,'rgba(70,120,200,.15)'); g1.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=g1; ctx.fillRect(0,0,WORLD.w,WORLD.h);
    const g2 = ctx.createRadialGradient(WORLD.w*0.75, WORLD.h*0.65, 10, WORLD.w*0.75, WORLD.h*0.65, 200);
    g2.addColorStop(0,'rgba(200,120,70,.12)'); g2.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=g2; ctx.fillRect(0,0,WORLD.w,WORLD.h);
    // stars (subtle twinkle)
    for(const s of stars){
      s.y += 8*s.z*0.016; if (s.y > WORLD.h) s.y -= WORLD.h;
      const tw = 0.2 + 0.25*Math.sin(t*3 + s.p);
      ctx.globalAlpha = 0.25*s.z + tw*0.2;
      ctx.fillStyle = '#a9c3ff';
      ctx.fillRect(s.x, s.y, 1*s.z, 1*s.z);
    }
    ctx.globalAlpha = 1;
    // small planets (very faint)
    for(const p of planets){
      p.y += p.vy*0.016; if(p.y > WORLD.h + 40){ p.y = -40; }
      ctx.globalAlpha = 0.15;
      ctx.fillStyle=p.col; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
      if(p.ring){ ctx.strokeStyle='rgba(255,230,180,.4)'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.ellipse(p.x,p.y+1,p.r+5,p.r/2,0,0,Math.PI*2); ctx.stroke(); }
      ctx.globalAlpha = 1;
    }
  }

  function drawRustWall(){
    // Glow rim
    ctx.strokeStyle = 'rgba(255,180,80,.25)'; ctx.lineWidth = 10;
    ctx.strokeRect(FIELD.x-3, FIELD.y-3, FIELD.w+6, FIELD.h+6);
    // Main border
    const g = ctx.createLinearGradient(0,FIELD.y,0,FIELD.y+FIELD.h);
    g.addColorStop(0,'#ffb23c'); g.addColorStop(1,'#cc7a17');
    ctx.strokeStyle = g; ctx.lineWidth = 7; ctx.strokeRect(FIELD.x, FIELD.y, FIELD.w, FIELD.h);
    // Rivets
    ctx.fillStyle='rgba(255,255,255,.18)';
    for(let x=FIELD.x+10; x<FIELD.x+FIELD.w-10; x+=26){ ctx.fillRect(x, FIELD.y-2, 2,2); ctx.fillRect(x, FIELD.y+FIELD.h, 2,2); }
    for(let y=FIELD.y+10; y<FIELD.y+FIELD.h-10; y+=26){ ctx.fillRect(FIELD.x-2,y,2,2); ctx.fillRect(FIELD.x+FIELD.w,y,2,2); }
  }

  function drawHUDInside(){
    const pad = 6;
    // Hearts top-right
    let hx = FIELD.x + FIELD.w - pad, hy = FIELD.y + pad + 1;
    for(let i=0;i<player.lives;i++) drawHeart(hx - i*12, hy, 5.5);
    // Shield charges indicator
    if(player.shieldCharges>0){
      ctx.fillStyle='#6bd1ff'; ctx.font='10px system-ui'; ctx.textAlign='right'; ctx.textBaseline='top';
      ctx.fillText(`Shield x${player.shieldCharges}`, FIELD.x+FIELD.w-pad, hy+12);
    }
    // Collected Sign (tiny)
    ctx.fillStyle='#cfe5ff'; ctx.font='10px system-ui'; ctx.textAlign='right'; ctx.textBaseline='top';
    ctx.fillText(`Collected Sign: ${player.collected}`, FIELD.x+FIELD.w-pad, hy+24);

    // Active tags (top-left)
    let bx = FIELD.x + pad, by = FIELD.y + pad + 1;
    const act = [];
    if(player.spread>0) act.push('Sp');
    if(player.rapid>0)  act.push('Rf');
    if(player.side>0)   act.push('Sd');
    if(player.missileTimer>0) act.push('Ms');
    ctx.font='9px system-ui'; ctx.textAlign='left'; ctx.textBaseline='top';
    for(const tag of act){
      ctx.fillStyle='rgba(255,255,255,.12)'; ctx.fillRect(bx,by,16,10);
      ctx.strokeStyle='rgba(255,255,255,.2)'; ctx.strokeRect(bx,by,16,10);
      ctx.fillStyle='#cfe5ff'; ctx.fillText(tag,bx+2,by+1);
      bx += 18;
    }
  }
  function drawHeart(x,y,r){
    ctx.save(); ctx.translate(x,y); ctx.fillStyle='#ff6b81';
    ctx.beginPath(); ctx.moveTo(0, r);
    ctx.bezierCurveTo(r, r-5, r, -r/2, 0, -r/3);
    ctx.bezierCurveTo(-r, -r/2, -r, r-5, 0, r);
    ctx.fill(); ctx.restore();
  }

  function drawPlayer(){
    const px = player.x, py = player.y;
    const sprite = playerImgProcessed || playerImg;
    if(sprite){
      const iw = sprite.width, ih = sprite.height;
      const s = 34 / Math.max(iw, ih);
      ctx.save(); ctx.translate(px, py); ctx.scale(s, s);
      ctx.drawImage(sprite, -iw/2, -ih/2, iw, ih); ctx.restore();
    }else{
      // fallback arrow if missing
      ctx.save(); ctx.translate(px,py);
      ctx.fillStyle='#f5d14a'; ctx.strokeStyle='#6a4b00'; ctx.lineWidth=1.5;
      ctx.beginPath(); ctx.moveTo(18,0); ctx.lineTo(-16,-10); ctx.lineTo(-8,0); ctx.lineTo(-16,10); ctx.closePath(); ctx.fill(); ctx.stroke();
      ctx.restore();
    }
    // Side pods visible when active
    if(player.side>0){
      ctx.fillStyle='#ffd96a'; ctx.strokeStyle='#6a540e'; ctx.lineWidth=1.2;
      ctx.beginPath(); ctx.roundRect(px-20,py-6,6,12,3); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.roundRect(px+14,py-6,6,12,3); ctx.fill(); ctx.stroke();
    }
  }

  function drawBullets(arr, friendly){
    for(const b of arr){
      if(friendly){
        if(b.isMissile){
          ctx.fillStyle = '#ffef9a';
          ctx.beginPath(); ctx.moveTo(b.x, b.y-6); ctx.lineTo(b.x+3, b.y+6); ctx.lineTo(b.x-3, b.y+6); ctx.closePath(); ctx.fill();
        }else{
          ctx.strokeStyle = '#fffbd1';
          ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(b.x,b.y); ctx.lineTo(b.x, b.y+5); ctx.stroke();
        }
      }else{
        ctx.fillStyle = '#ff6a6a'; ctx.beginPath(); ctx.arc(b.x,b.y,2.4,0,Math.PI*2); ctx.fill();
      }
    }
  }

  // Enemy engine flame + extra anim
  function drawEngineFlame(x,y,wide=6,long=10){
    const t = performance.now()*0.003;
    const len = long + Math.sin(t*9+y)*2;
    const g = ctx.createRadialGradient(x,y+2,1, x,y+len, len);
    g.addColorStop(0,'rgba(255,240,180,.9)');
    g.addColorStop(0.5,'rgba(255,160,40,.7)');
    g.addColorStop(1,'rgba(255,90,10,0)');
    ctx.fillStyle=g; ctx.beginPath(); ctx.ellipse(x, y+len*0.6, wide*0.55, len, 0, 0, Math.PI*2); ctx.fill();
  }

  // Enemies — face downward (rotated); simplified for brevity
  function drawEnemy(e){
    ctx.save(); ctx.translate(e.x,e.y); ctx.rotate(Math.PI);
    const blink = (Math.sin(e.t*6)+1)*0.5;
    switch(e.type){
      case 'redRocket': {
        ctx.fillStyle='#ef4545'; ctx.strokeStyle='#6b1a1a'; ctx.lineWidth=1.4;
        ctx.beginPath(); ctx.roundRect(-9,-16,18,28,6); ctx.fill(); ctx.stroke();
        ctx.fillStyle=`rgba(255,220,170,${0.25+0.5*blink})`; ctx.fillRect(-6,-2,12,4);
        ctx.fillStyle='#234463'; ctx.beginPath(); ctx.ellipse(0,-6,6,5,0,0,Math.PI*2); ctx.fill();
        drawEngineFlame(0,12,6,14); break;
      }
      case 'blueRocket': {
        ctx.fillStyle='#5aa5ff'; ctx.strokeStyle='#1c3a6b'; ctx.lineWidth=1.4;
        ctx.beginPath(); ctx.roundRect(-8,-18,16,30,8); ctx.fill(); ctx.stroke();
        ctx.fillStyle='#183154'; ctx.beginPath(); ctx.ellipse(0,-8,5,4,0,0,Math.PI*2); ctx.fill();
        ctx.fillStyle=`rgba(143,194,255,${0.4+0.4*blink})`; ctx.fillRect(-8,-2,16,2);
        drawEngineFlame(0,12,5,13); break;
      }
      case 'whiteOrange': {
        ctx.fillStyle='#eaecef'; ctx.strokeStyle='#61646b'; ctx.lineWidth=1.2;
        ctx.beginPath(); ctx.roundRect(-8,-18,16,30,6); ctx.fill(); ctx.stroke();
        ctx.fillStyle=`rgba(255,178,60,${0.5+0.4*blink})`; ctx.fillRect(-8,2,16,3);
        drawEngineFlame(0,12,5.5,14); break;
      }
      case 'domeUFO': {
        ctx.fillStyle='#ffcf6a'; ctx.strokeStyle='#6a4b00'; ctx.lineWidth=1.2;
        ctx.beginPath(); ctx.ellipse(0,6,16,6,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.fillStyle='#98d7ff'; ctx.beginPath(); ctx.ellipse(0,-2,10,7,0,0,Math.PI*2); ctx.fill();
        for(let i=0;i<4;i++){ const a=e.t*3 + i*Math.PI/2; ctx.fillStyle='rgba(255,240,200,.7)'; ctx.beginPath(); ctx.arc(Math.cos(a)*10, 6+Math.sin(a)*1.2, 1.2, 0, Math.PI*2); ctx.fill(); }
        drawEngineFlame(-8,10,3.5,9); drawEngineFlame(8,10,3.5,9); break;
      }
      case 'ringSaucer': {
        ctx.fillStyle='#f2b36c'; ctx.strokeStyle='#6b3a0f'; ctx.lineWidth=1.2;
        ctx.beginPath(); ctx.ellipse(0,0,12,8,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.save(); ctx.rotate(Math.sin(e.t*2)*0.15); ctx.strokeStyle='rgba(240,210,160,.9)'; ctx.beginPath(); ctx.ellipse(0,2,20,6,0,0,Math.PI*2); ctx.stroke(); ctx.restore();
        drawEngineFlame(-6,8,3,9); drawEngineFlame(6,8,3,9); break;
      }
      case 'diamondShip': {
        ctx.fillStyle='#cde1ff'; ctx.strokeStyle='#224565'; ctx.lineWidth=1.2;
        ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(10,0); ctx.lineTo(0,12); ctx.lineTo(-10,0); ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.fillStyle=`rgba(137,183,255,${0.4+0.4*blink})`; ctx.fillRect(-8,-1,16,2);
        drawEngineFlame(0,10,4.5,11); break;
      }
    }
    ctx.restore();
  }

  // Power-ups: spread, rapid, side, shield (charges), health (+1), missile (boss only)
  function drawPowerup(p){
    ctx.save(); ctx.translate(p.x,p.y);
    switch(p.type){
      case 'shield':{ const g = ctx.createRadialGradient(0,0,2,0,0,10); g.addColorStop(0,'#cfe9ff'); g.addColorStop(1,'#3a79c6');
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
        ctx.strokeStyle='#6bd1ff'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.stroke(); break; }
      case 'rapid':{ ctx.fillStyle='#d0f4ff'; ctx.strokeStyle='#2a4c68'; ctx.lineWidth=1.5;
        ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.strokeStyle='#3a5e7c'; for(let i=0;i<6;i++){ const a=i*(Math.PI/3); ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(a)*8, Math.sin(a)*8); ctx.stroke(); } break; }
      case 'spread':{ ctx.fillStyle='#8fffd6'; for(let i=0;i<3;i++){ const a=i*(2*Math.PI/3); ctx.beginPath(); ctx.arc(Math.cos(a)*6, Math.sin(a)*6, 4, 0, Math.PI*2); ctx.fill(); }
        ctx.fillStyle='#1c3a32'; ctx.beginPath(); ctx.arc(0,0,2,0,Math.PI*2); ctx.fill(); break; }
      case 'side':{ ctx.fillStyle='#ffd96a'; ctx.strokeStyle='#6a540e'; ctx.lineWidth=1.2;
        ctx.beginPath(); ctx.roundRect(-14,-6,8,12,3); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.roundRect(6,-6,8,12,3); ctx.fill(); ctx.stroke(); break; }
      case 'health':{ ctx.fillStyle='#ff6b81'; ctx.beginPath(); ctx.moveTo(0,8); ctx.bezierCurveTo(8,2,8,-6,0,-4); ctx.bezierCurveTo(-8,-6,-8,2,0,8); ctx.fill(); break; }
      case 'missile':{ ctx.fillStyle='#ffef9a'; ctx.beginPath(); ctx.moveTo(0,-10); ctx.lineTo(7,10); ctx.lineTo(-7,10); ctx.closePath(); ctx.fill();
        ctx.strokeStyle='#d4c36a'; ctx.stroke(); break; }
    }
    ctx.restore();
  }

  // Boss visuals and shooting
  function drawBoss(b){
    ctx.save(); ctx.translate(b.x,b.y);
    const metal = (x0,y0,x1,y1,c1,c2)=>{const g=ctx.createLinearGradient(x0,y0,x1,y1);g.addColorStop(0,c1);g.addColorStop(1,c2);return g;};
    switch(b.index){
      case 1:{ ctx.fillStyle=metal(0,-24,0,24,'#f3d67a','#7f5a0a'); ctx.beginPath(); ctx.ellipse(0,10,80,24,0,0,Math.PI*2); ctx.fill();
               ctx.fillStyle='#1c2e49'; ctx.beginPath(); ctx.ellipse(0,-8,40,18,0,0,Math.PI*2); ctx.fill(); break; }
      case 2:{ ctx.fillStyle=metal(0,-28,0,28,'#ff89a3','#6b1a2e'); ctx.beginPath(); ctx.ellipse(0,0,70,28,0,0,Math.PI*2); ctx.fill();
               ctx.fillStyle='#6b1a2e'; ctx.fillRect(-90,10,30,8); ctx.fillRect(60,10,30,8); break; }
      case 3:{ ctx.fillStyle=metal(-80,0,80,0,'#c9bbff','#3c2f79'); ctx.beginPath(); ctx.moveTo(0,-30); ctx.lineTo(80,30); ctx.lineTo(-80,30); ctx.closePath(); ctx.fill(); break; }
      case 4:{ ctx.fillStyle=metal(0,-60,0,60,'#a6ffff','#236c6c'); ctx.beginPath(); ctx.arc(0,0,60,0,Math.PI*2); ctx.fill();
               ctx.fillStyle='#112338'; ctx.beginPath(); ctx.arc(0,0,24,0,Math.PI*2); ctx.fill(); break; }
    }
    // Health bar above boss (inside wall)
    const w=120, h=8; const pct = Math.max(0,b.hp/b.hpMax);
    ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(-w/2, -50, w, h);
    const grad = ctx.createLinearGradient(-w/2,0,w/2,0); grad.addColorStop(0,'#ff5d6c'); grad.addColorStop(1,'#ffb23c');
    ctx.fillStyle=grad; ctx.fillRect(-w/2, -50, w*pct, h);
    ctx.strokeStyle='rgba(255,255,255,.2)'; ctx.strokeRect(-w/2, -50, w, h);
    ctx.restore();
  }
  function bossShoot(b){
    const add = (x,y,vx,vy)=> eBullets.push({x,y,vx,vy});
    if(b.index===1){
      if(b.phase===1){ for(let a=-0.3;a<=0.3;a+=0.3) add(b.x,b.y+25, Math.sin(a)*110, 160); }
      else if(b.phase===2){ for(let i=-2;i<=2;i++){ const a=i*0.18; add(b.x,b.y+25, Math.sin(a)*130, 180); } }
      else { const a=b.patternAngle*3; add(b.x+Math.cos(a)*30,b.y+25, Math.cos(a)*120, 200); add(b.x+Math.cos(a+Math.PI)*30,b.y+25, Math.cos(a+Math.PI)*120, 200); }
    } else if(b.index===2){
      if(b.phase===1){ for(let i=0;i<4;i++){ const a=(-0.35+i*0.23)+Math.sin(b.t*0.8)*0.2; add(b.x,b.y+20, Math.sin(a)*140,180);} }
      else if(b.phase===2){ for(let i=-1;i<=1;i++){ add(b.x+i*20,b.y+18, i*40,210);} }
      else { const a=b.patternAngle*4; for(let k=0;k<2;k++){ const ang=a+(k*Math.PI); add(b.x+Math.cos(ang)*40,b.y+20, Math.cos(ang)*140,220);} }
    } else if(b.index===3){
      if(b.phase===1){ for(let i=0;i<3;i++){ const a=(-0.25+i*0.25); add(b.x,b.y+28, Math.sin(a)*130, 200);} }
      else if(b.phase===2){ for(let i=0;i<10;i++){ const a=i*(Math.PI*2/10); add(b.x+Math.cos(a)*20,b.y+20, Math.cos(a)*100,140);} }
      else { const a=b.patternAngle*6; for(let i=0;i<3;i++){ const ang=a+i*0.9; add(b.x+Math.cos(ang)*34,b.y+18, Math.cos(ang)*160,240);} }
    } else if(b.index===4){
      if(b.phase===1){ for(let i=-3;i<=3;i++){ const a=i*0.12; add(b.x,b.y+10, Math.sin(a)*150,210);} }
      else if(b.phase===2){ const a=b.patternAngle*5; add(b.x+Math.cos(a)*30,b.y+10, Math.cos(a)*170,230); add(b.x,b.y+12,0,260); }
      else { const a=b.patternAngle*7; for(let k=0;k<3;k++){ const ang=a+k*(2*Math.PI/3); add(b.x+Math.cos(ang)*38,b.y+12, Math.cos(ang)*190,260);} }
    }
  }
  function bossHitbox(b){ return {x:b.x-90,y:b.y-50,w:180,h:100}; }
  function rectHitPoint(r, x,y){ return x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h; }

  // Signs
  function drawSign(s){
    ctx.save(); ctx.translate(s.x,s.y);
    ctx.font='italic 12px "Trebuchet MS", Arial, sans-serif';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.shadowColor='rgba(255,166,49,.75)'; ctx.shadowBlur=8;
    ctx.fillStyle='#ff9a2a'; ctx.fillText('Sign',0,0);
    ctx.shadowBlur=0; ctx.restore();
  }

  // Player fire (bullets do 10 vs boss)
  function firePlayer(){
    const speed = -440;
    const add = (x,y,vx,vy)=> bullets.push({x,y,vx,vy,dmgBoss:10});
    add(player.x, player.y-18, 0, speed);
    if(player.spread>0){ add(player.x,player.y-18,-100,speed); add(player.x,player.y-18,100,speed); }
    if(player.side>0){ add(player.x-14,player.y-10,0,speed*0.96); add(player.x+14,player.y-10,0,speed*0.96); }
  }
  function fireMissile(){
    if(!boss) return;
    // Slightly home horizontally toward boss
    const dx = boss.x - player.x;
    const vx = clamp(dx*2, -160, 160);
    bullets.push({x:player.x, y:player.y-18, vx, vy:-280, isMissile:true});
  }
  function explodeAt(x,y){
    // Add a round explosion effect
    effects.push({x,y,life:0.5,t:0,expl:true});
  }
  function drawExplosion(f){
    const t = f.t/f.life;
    const r = 8 + t*22;
    const grad = ctx.createRadialGradient(f.x,f.y,0, f.x,f.y,r);
    grad.addColorStop(0,'rgba(255,240,150,0.9)');
    grad.addColorStop(0.5,'rgba(255,150,60,0.7)');
    grad.addColorStop(1,'rgba(255,80,30,0)');
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(f.x,f.y,r,0,Math.PI*2); ctx.fill();
  }

  // Collisions / utilities
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function circleHit(a,b, r){ const dx=(a.x-b.x), dy=(a.y-b.y); return dx*dx+dy*dy <= r*r; }
  function clientToWorld(cx,cy){
    const rect = canvas.getBoundingClientRect();
    const px = (cx-rect.left) * (canvas.width/rect.width);
    const py = (cy-rect.top) * (canvas.height/rect.height);
    const x = px/scale - padX;
    const y = py/scale - padY;
    return { x, y };
  }

  function loseLife(){ if(player.invuln>0) return; player.lives--; player.invuln=0.7; if(player.lives<=0) gameOver(); }
  function hitPlayer(){
    if(player.invuln>0) return;
    if(player.shieldCharges>0){ player.shieldCharges--; player.invuln=0.5; spawnPop(player.x,player.y); return; }
    loseLife(); spawnPop(player.x,player.y);
  }

  function spawnPop(x,y){ for(let i=0;i<12;i++){ effects.push({x,y,vx:(Math.random()-0.5)*140,vy:(Math.random()-0.8)*160,life:0.4,t:0,color:'#ffd37a'}); } }
  function spawnBigExplosion(x,y){ for(let i=0;i<80;i++){ effects.push({x,y,vx:(Math.random()-0.5)*240,vy:(Math.random()-0.5)*240,life:0.9,t:0,color: i%2? '#ff9a3c':'#ffd37a'}); } }

  // Kick off
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
